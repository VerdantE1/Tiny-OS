## 基础：makefile基本语法

##### 语法：

```asm
目标文件:依赖文件
[Tab]命令
```











##### 约定成俗的伪目标名称：

伪目标，顾名思义，也就是不产生真实的目标文件，所以当然也就不需要依赖文件了。于是，伪目标所在 的规则就变成了纯粹地执行命令，只要给 make 指定该伪目标名做参数，就能让伪目标规则中的命令直接执行。

![image-20220725104236089](D:/TYPIC/image-20220725104236089.png)

注意，伪目标不能和真实目标文件同名，否则就失去伪目标的意义了，为了 避免伪目标和真实目标文件同名的情况，可以用关键字“.PHONY”来修饰伪目 标，格式为“.PHONY:伪目标名”，这样不管与伪目标同名的文件是否存在，make 照样执行伪目标处的命令。





##### 自定义变量和系统变量

自定义变量：

**变量定义的格式**:变量名=值（字符串），多个值之间用空格分开。make 程序在处理时会用空格将值打散， 然后遍历每一个值。另外，值仅支持字符串类型，即使是数字也被当作字符串来处理

**变量引用的格式**：$(变量名)。这样，每次引用变量时，变量名就会被其值（字符串）替换。

```makefile
objfiles = test1.o test2.o 
test.bin:$(objfiles) 
	gcc -o test.bin $(objfiles) 
```

系统级变量：

![image-20220725105221367](D:/TYPIC/image-20220725105221367.png)

![image-20220725105342577](D:/TYPIC/image-20220725105342577.png)



若想通过隐含规则自动推导生成目标，存在于文件系统上的文件，除 扩展名之外的文件名部分必须相同。比如 x.o 的 C 源文件必须名为 x.c，这样通过隐含规则才能成功生成 x.o。 隐含规则是用系统变量来实现的，比如咱们例子中用到了命令变量CC 及参数变量CFLAGS 及CPPFLAGS， 变量 CC 的值为 cc，所以这里用 CC 来编译 C 源码文件

![image-20220725105804911](D:/TYPIC/image-20220725105804911.png)



自动化变量：

![image-20220725110032511](D:/TYPIC/image-20220725110032511.png)

![image-20220725110043577](D:/TYPIC/image-20220725110043577.png)



模式规则：

