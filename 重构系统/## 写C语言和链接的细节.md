## 写C语言和链接的细节

注意一些细节：



**1.sizeof非库函数，是C语言保留关键字**

**2.C语言的指针是不能参与运算，要使其参与运算要转化成整型，转化整型时只能转换成同位数的整型，比如32位指针只能转化成32位整数。**

**3.界限值=大小-1**，相当于在原有地址上能增加多少到哪个界限，以0为基数

4.

```asm
intr_entry_table:

%macro VECTOR 2
section .text
intr%1entry:		 ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少
   %2
   push intr_str
   call put_str
   add esp,4			 ; 跳过参数

   ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI 
   mov al,0x20                   ; 中断结束命令EOI
   out 0xa0,al                   ; 向从片发送
   out 0x20,al                   ; 向主片发送

   add esp,4			 ; 跨过error_code
   iret				 ; 从中断返回,32位下等同指令iretd

section .data
   dd    intr%1entry	 ; 存储各个中断入口程序的地址，形成intr_entry_table数组
%endmacro
VECTOR 0x00,ZERO
VECTOR 0x01,ZERO
VECTOR 0x02,ZERO
VECTOR 0x03,ZERO 
VECTOR 0x04,ZERO
```

像这种最后编译后，data会在一起，形成了intr_entry_table数组，intr_entry_table[i]就是第i-1个地址





5.编译器只负责编址。编译器给程序中各符号（变量名或函数名等）分配的地址，**就是各符号相对于文件开头的偏移量**

**链接的过程实际上是为了解决多个文件之间的符号引用问题。编译时编译器只对单个文件进行处理，如果该文件里面需要引用到其他文件中的符号（例如全局变量和函数），那么这时在这个文件中该符号的地址是没法确定的，只能等链接把所有目标文件连接到一起才能确定最终的地址。**

这个填写地址的过程，ld做的事主要是解决链接时的重定位，即为符号分配地址，以使得源文件可以根据符号找到地址。这里会引入一个重定位表的数据结构，在ELF文件中是以segment的方式存在，通常叫.rel.data和.rel.text（分别对应数据段和代码段的重定位表），定义在elf.h中。







![image-20220724125436840](D:/TYPIC/image-20220724125436840.png)

这是一个可重定位目标文件的重定位表。



注意可执行目标文件并不需要重定位信息，因此通常省略，除非用户显式的包含这些信息



##### 编译器对待全局变量和局部变量

编译器只允许每个模块中每个局部符号只有一个定义，静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。

不过，对全局符号的引用解析就比较棘手，当编译器遇到一个不是在当前模块中定义的符号时，会假设该符号是在其他某个模块中定义的，**生成一个链接器符号条目**就如上的b，并把它交给链接器处理。如果链接器在它的任何输入模块中找不到这个被引用符号的定义，就输出一条错误信息并终止，如undefined-reference to XXX.像这种编译能通过但是链接通过不了。



##### 链接器对待全局变量（链接器对局部变量没意义）

如果多个目标文件定义了相同名字的全局符号，这种情况，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。

在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表（.symbol）里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。**强符号和弱符号都是对全局（函数，全局变量）的，而非局部的**

根据强弱符号的定义，LINUX链接器使用下面的规则来处理多重定义的符号名：

- 规则1:不允许有多个同名的强符号
- 规则2：如果有一个强符号和多个弱符号同名，那么选择强符号
- 规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个





###### C++和JAVA中链接器符号的重整

C++和JAVA都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表，那么链接器是如何区别这些不同的重载函数之间的差异呢？**是因为编译器将每个唯一的函数和参数列表组合编码成一个对链接器来说唯一的名字。这个编码的过程叫重整，而相反的过程叫恢复**。幸运的是，C++和JAVA使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类FOO被编码成3FOO。函数被编码为原始函数明，后面加上___,加上被重整的类名，再加上每个参数的单字母编码。比如FOO::BAR(int,long)被编码为bar`__`3FOOil









只激活预处理，编译和汇编，不进行链接

```shell
gcc -c
```



查看重定位表  

```shell
objdump -r  注意是重定位表不是整个结构
```

反汇编查看代码

```shell
objdump -d
注意里面机器码是小端  如e8 fc ff ff ff  实际上是fffffffce8
```

