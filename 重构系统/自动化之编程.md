## 字符串抽象

技巧：把'\0'也当字符串,其是最小的字符串,但是一旦遍历到\0必须退出字符加减了否则出界了

#### 1.移动到\0的后面一位

```c
while (*c++); //asd'\0'  
```

#### 2.条件表达式表达三种情况

```c
return *a < *b ? −1 : *a > *b; 
```

#### 3.将src后面包括\0全部接在dst为起始的位置了

```c
while( (*dst++ = *src++))
```









## 逻辑条件

#### 1.a||b本来是代表三个条件a && b  || !a && b || a && !b 通过一种筛选使得a || b 只代表两个条件即 !a || b  && a || !b

```c
if(a && b) {
    //将a && b筛选出去
}
else if(a || b) {
    
}
```

#### 2.自动化取反

```c
if(condtion){
    a = !a;
}
```















## 组合功能

#### 1.实现类似shift键：**同时的抽象化**，**两种映射**

**要有三个抽象：本次状态，上次状态，本次信号. 上次状态用全局变量修饰以供本次调用**。







**同时的条件是  {上次shift_last_state是激活的 && 本次不是shift的断码}**

不同步的条件为：1.{!shift_last_state}   2.{shift_last_state && code =breakdown() && code == SHT};



若上次状态是激活的则判断本次的同步条件是否成立，若成立则同步 不成立则不同步。若上次状态是不激活的本次状态一定不同步。

```c
~
#define SHT XXX;
bool shift_last_state;  //上次状态
int f(){
    bool shift =false;   //本次状态
    
    int code = getcode();  //本次编码
    code = codeorbreakcode(); //通码还是断码
    
    if(breakdown()){  //若是断码
        if(code == SHT) shift = shift_last_state =false;
        else ......
            
    }
    
    else{   //若是通码
        shift = shift_last_state;
        ......... //if(shift 第一种映射)  else(第二种映射)
            
    }
    
    
}
```

