

# 为什么操作系统中应用程序的栈空间设置最大值，不支持动态扩展？

看下面的图：

![img](https://pic3.zhimg.com/50/v2-957f4c83e14d294b9285b54ff55a02fb_720w.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-957f4c83e14d294b9285b54ff55a02fb_720w.jpg?source=1940ef5c)

题主之所以能问出这个问题，也许是因为大多数内存的理论模型都会画成左边那样子。那么自然而然的Heap可以不断往上扩展；Stack可以往下扩展。

但现实中是
\1. 主流操作系统都是有多线程支持的，而多线程需要每个线程分配一个独立的Stack，每个Stack内部可以满足“向下增长“，但是必须要有个界限，不然没法实现了。否则下个Stack从哪开始呢？

\2. [heap](https://www.zhihu.com/search?q=heap&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A676446301})和mmap segment的存在。[mmap](https://www.zhihu.com/search?q=mmap&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A676446301})是有很多用途的。比如

- 加载一个so动态库，是以mmap的形式映射到内存里，再让CPU执行上面的指令的；每个程序都会加载大量的[动态库](https://www.zhihu.com/search?q=动态库&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A676446301})。
- 我们编程意义上的heap实际上是操作系统级别heap和mmap区域的混合。当分配一大块内存时，操作系统可能会决定不从heap里切，而是独立分配一块mmap区域来用。
- mmap自己也可以被用户直接使用，比如映射一个文件，或者做内存的数据共享。

上图中之所以把heap，mmap segement和stack画成一个颜色，是因为他们本质上差不太多，都是程序运行时动态分配和调整的。stack和mmap都是“一块内存”，因此实现中并不一定非得是Stack永远比mmap的地址数值更大。只要不重叠就行了。Linux本身的api也允许创建新线程时，指定一段内存作为“Stack”，而这个内存自然也需要通过malloc得到，这又回到了mmap/heap上了。

回到应用层面，巨大的Stack除了应付非常深的递归之外没有什么太大的用处。而非常深的递归一般就是程序哪里写bug了。为了不太有用的场景去做设计并不是理智的行为。

我们常规意义上说“Stack”实际只是在用CPU对一段内存的地址做[指令寄存器](https://www.zhihu.com/search?q=指令寄存器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A676446301})的push和pop而已。如果这不够用你可以自行定制一个喜欢的形式来实现对Stack的管理。有些语言可以把Stack的管理玩出花。比如go，自己实现了对go routine的管理，每个routine的Stack都可以不是连续的，这样既避免浪费，又能轻松扩展。