## 内联汇编

```asm
asm [volatile] (“assembly code” : output : input : clobber/modify): 
```

 采用AT&86，利用限制条件去编写

input是要修改的值，out是参考读取的值。

N表示立即数限制，d表示使用dx,dl,edx

a表示ax,al,eax，c表示cx,cl,ecx

+表示既做输出又做输入



例子：

```asm
asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port)); 
```

首先必须要清楚，outb 指令格式为 outb %al，%dx，其中%al 是源操作数，指的是 8 位数据，%dx 是 目的操作数，指的是数据所写入的端口。 我们要做的是通过 gcc 提供的各种约束和机器模式操作码将内联汇编形式凑成 outb %al，%dx，咱们 一点点分析下是怎么做到的。 从右边的 input 开始看，形参变量 port 的约束有 2 个，分别是 N 和 d。N 为立即数约束，它表示 0～ 255 的立即数，也就是 8 位 1 字节所表示的范围，这样把写入的数据限制在 1 字节之内。d 为寄存器约束， 它表示让 gcc 为 port 分配的寄存器可以是 dl、dx 或 edx。outb 的目的操作数是 dx，我们得想办法将寄存 器明确为 dx。这可以用操作码 w 来实现，它表示使用寄存器的 HImode 名称，即寄存器中 2 字节的那个 可独立使用的部分，也就是[a-d]x。操作码是跟序号占位符配合在一起来使用的，所以操作码 w 要随着序 号占位符在内联汇编的“assembly code”中使用。大家看“assembly code”，port 所对应约束的序号占位符 是%1，我们目的是使用 dx 寄存器，所以用%w1 来限制目的操作数为寄存器 dx。 继续说 output 中的 data 变量，它对应的约束为 a，这表示用寄存器 al、ax 或 eax 来存储该变量的值， 前面说过 outb 指令的源操作数是寄存器 al，我们也必须将源操作数使用的寄存器明确为 al 才行。这可以 通过机器模式操作码 b 来实现，操作码 b 表示寄存器的 QImode 部分，也就是寄存器中最低 8 位可独立使 用的部分，即[a-d]l。同理，在“assembly code”中用%b0 表示 al 寄存器。 到现在为止，我们已经凑成了“outb %al，%dx”的形式，咱们的任务完成，接下来就是上处理器执行了。