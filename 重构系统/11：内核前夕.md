## 11.内核前夕

##### 一.一些说明

汇编语言相对来说运用在较低层级上，它是为完成宏观需求的具体步骤，在程序语言层面，汇编语言可以认为是不能再细分的最基本的原子。

C语言编写的程序：重定位指的是文件里面的符号还没有被安排地址，这些符号的地址需要将来与其他目标文件“组成”一个可执行文件时再重新定位（编排地址），这里的符号就是指该目标文件中所调用的函数或使用的变量。这里的“组成”就是链接。哪怕可执行文件只是由一个文件组成的，其目标文件中的符号也是未编址的，编址工作，即重定位，一律统一在链接阶段完成。

一个程序总该有个入口地址，这个地址表示的是程序将从哪里开始执行。要知道，并不是程序体中的第一个字节就是程序的起始地址，因为在程序的开头可能有函数声明或数据定义，由于程序内的地址是在链接阶段编排的，**所以在链接阶段必须要明确入口地址才行，于是链接器规定默认只把名为_ start的函数作为程序的入口地址，即默认的entry_symbol是_ start，除非另行指定。main函数并不是第一个函数，它实际上是被别人调用。**



##### 二.二进制文件的运行

用户程序不像操作系统一样生来含着“金铲铲”，用户程序一出来并没有加载到内存而是在外存，要想运行任何程序，必须将其安放在内存，于是用户程序是被加载到内存后再运行的。那么，如何加载到内存中去呢？操作系统是软件，用户程序也是软件，用一个程序调用另外一个程序一点难度都没有，最简单的办法就是jmp或call，回顾之前，BIOS系统就是这样调用mbr的，我们写的mbr也是像这样调用loader.bin的，但是我们当时调用之时，mbr地址是固定的0x7c00，loader地址也是固定的0x900，也就是说我们的调用方法不灵活，地址是之前就开始约定好了的。

那么有不有一种灵活的办法让程序加载地址不那么固定？

每个程序是单独存在的，**每个程序的入口地址信息都是需要与程序进行绑定的**。最简单的办法就是在程序文件中专门腾出个空间来写入这些程序，主调程序在该程序文件的相应空间中将该程序的入口信息读出来，将其加载到相应的入口地址，跳转过去即可。当然不仅仅可以写程序入口，还有很多信息可以加入，比如程序的长度即需要分配的内存空间尺寸。**所以这就是文件头的由来**，程序的开头即文件头记载了这些信息，程序文件除了开头的文件头，余下部分都是程序体。

![image-20220710141302008](D:/TYPIC/image-20220710141302008.png)

```shell
[work@localhost book]$ cat -n header.S 
 1 header: 
 2 program_length dd program_end-program_start 
 3 start_addr dd program_start 
 4 ;;;;;;; 以上是文件头，以下是文件体 ;;;;;;; 
 5 body: 
 6 program_start：
 7 mov ax, 0x1234 
 8 jmp $ 
 9 program_end: 
 10 
[work@localhost book]$ 
```

这是一个自定义文件头实例，下面是程序体，上面是文件头，调用方程序可以将header.bin的前8个字节读入到内存中，然后将开头偏移8作为起始地址，  开头偏移（8+程序体长度）作为终止地址，然后将起始地址和终止地址之间的程序体复制到入口地址。最后转到入口地址执行。	

虽然这是自定义的文件头但是不通用，咱们是在linux下C语言编程，其编译器gcc生成的是elf文件格式，故详阐述elf可执行文件格式的内容。

linux下的 elf结构在/user/include/elf.h中找到







###### 三.elf文件格式的二进制文件

elf中的目标文件

![image-20220710141807553](D:/TYPIC/image-20220710141807553.png)





程序中最重要的部分就是段和节了，它们是真正的程序体，是真真切切的程序资源。段和节的信息也是用 header 来描述的，程序头是 program header，节头是 section header。程序中段的大小和数量是不固定的，节的大小和数量也不固定，因此需要为它们专门找个数据结构来描述它们，这个描述结构就是程序头表（program header table）和节头表（section header table）。

**也就是说程序头表（program header table）中的 元素全是程序头（program header），而节头表（section header table）中的元素全是节头（section header）。 虽然上面是将两个表一块说明的，但表中的元素全是单一的，不会在程序头表中存在节头信息。**在表中，每个成员（数组元素）都统称为条目，即 entry，一个条目代表一个段或一个节的头描述信息。 对于程序头表，它本质上就是用来描述段（segment）的，所以您也可以称它为段头表。从名字上就能够看出， 段等同于程序，所以将描述段信息的表说成 program header table，可见“段”才是程序本身的组成部分。

**由于程序中段和节的数量不固定，程序头表和节头表的大小自然也就不固定了，而且各表在程序文件 中的存储顺序自然也要有个先后，故这两个表在文件中的位置也不会固定。因此，必须要在一个固定的位 置，用一个固定大小的数据结构来描述程序头表和节头表的大小及位置信息，这个数据结构便是 ELF  header，它位于文件最开始的部分，并具有固定大小，一会儿咱们看 elf header 的数据结构就知道了。**

`ELF 文件格式依然分为文件头和文件体两部分，只是该文件头相对稍显复杂，类似层次化结构，先用 个 ELF header 从“全局上”给出程序文件的组织结构，概要出程序中其他头表的位置大小等信息，如程序头表的大小及位置、节头表的大小及位置。`

![image-20220710142151875](D:/TYPIC/image-20220710142151875.png)

相关ELF结构，PH结构详情解说在p217面





###### 四.将内核载入到内存

先给出内存布局

低1MB布局

![image-20220710175558248](D:/TYPIC/image-20220710175558248.png)



![image-20220710175746425](D:/TYPIC/image-20220710175746425.png)

1.设计内核映像的物理地址到0x1500地址处，我们要把内核安装在高3GB地址以上，所以赋予其虚拟地址0xc0001500

原因：

`物理内存中 0x900 处是 loader.bin 加载的地址，在 loader.bin 的开始部分是 GDT，它可是必须要保留 下来的，可不能覆盖，我们不打算在内核中重新定义它，以后都要指望它了。虽然 loader 的工作结束啦， 但 loader 所完成的工作成果咱们还得继续发扬，继续用。预计 loader.bin 的大小不会超过 2000 字节。所以 咱们可选的起始物理地址是 0x900+2000=0x10d0（不要把注意力放在这个奇怪的数上，偶然得出的）。内 存很大，但也尽量往低了选，于是凑了个整数，选了 0x1500 作为内核映像的入口地址。`



2.loader.bin的映像来加载内核，在loader.S中要改两部分

**加载内核：需要把内核文件加载到内存缓冲区。** （加载内核，这里所说的加载内核只是把内核从硬盘上拷贝到内存中，并不是运行内核代码。 这项工作在开启分页前后都可以，不过为了简单，咱们把它安排在分页开启之前加载）

**初始化内核：需要在分页后，将加载进来的 elf 内核文件安置到相应的虚拟内存地址，然后跳过去 执行，从此 loader 的工作结束。**(我们是在linux,gcc环境下编写的内核文件，所以默认情况下程序的头文件是 elf格式，要加载到我们的OS中去要根据头文件解引，将程序体载入我们的OS中)

加载内核，这是在分页开启之前做的工作

```asm
147 ; ------------------------- 加载 kernel ---------------------- 
148 mov eax, KERNEL_START_SECTOR ; kernel.bin 所在的扇区号
149 mov ebx, KERNEL_BIN_BASE_ADDR ; 从磁盘读出后，写入到 ebx 指定的地址
150 mov ecx, 200 ; 读入的扇区数
151 
152 call rd_disk_m_32 ;从外存中读取内核
153 
154 ; 创建页目录及页表并初始化页内存位图
155 call setup_page
```

初始化内核，这是在分页开启之后的工作



```asm
;dx:PH SIZE      ebx: 1st  PH PADDR即PH表基址     cx:PH  NUM
```









3.C语言规定任何参数是从右往左依次入栈如memset(dest,src,n) 顺序依次是n,src,dest

![image-20220710180802947](D:/TYPIC/image-20220710180802947.png)

利用esp存栈顶，利用ebp访问参数。然后pop要和push一一对应。再说下C语言标准库的memset，我们这里实现的跟标准库里面的很类似。

最后我们把栈指针改为0xc009f000对应物理地址为0x9f000即1MB最高处





4.mov指令族

`其中的 movs 代表 move string，后面的 b 代表 byte，w 代表 word，d 代表 dword。所以 movsb 的功能是搬运（复制）1 字节，movsw 的功能是搬运（复 制）2 字节，movsd 的功能是搬运（复制）4 字节。数据从哪里来，搬到哪里去呢？这三条指令是将 DS：[E]SI 指向的地址处的 1、2 或 4 个字节搬到 ES：[E]DI 指向的地址处，16 位环境下源地址指针用 SI 寄存器，目的 地址指针用 DI 寄存器，32 位环境下源地址则用 ESI，目的地址则用 EDI。话说虽然这三个指令叫字符串指令， 但它们可不是只用在字符串上，因为字符串中的字符不也是按字节来存储的吗，任何数据在内存中都以字节存 储单元来访问，字符串只是表象，本质上是复制字节，所以它更多地被通用于复制数据`



`rep 指令是 repeat 重复的意思，该指令是按照 ecx 寄存器中指定的次数重复执行后面的指定的指令，每执行 一次，ecx 自减 1，直到 ecx 等于 0 时为止，所以在用 rep 重复执行某个指令之前，一定要将 ecx 寄存器提前赋值。`





`似乎说完了，但其实还差点什么，您想，如果想要复制一大块数据的话，总该有人更新数据的来源和 目的地吧。movs[bwd]只是从[e]si 指向的地址处搬运 1、2、4 字节到[e]di 指向的地址处，它不会自动更新[e]si 和[e]di。咱们总不能翻来覆去从同一个源地址搬运数据到另一个相同的目的地址吧。所以，cld 和 sld 指令就 派上用场了，这两个指令本质上是控制重复执行字符串指令时的[e]si 和[e]di 的递增方式，递增方式是指它 们的值逐渐变大，还是逐渐变小，也就是说，地址是往高地址方向变化，还是往低地址方向变化，这就是所 说的方向。cld 是指 clean direction，该指令是将 eflags 寄存器中的方向标志位 DF 置为 0，这样 rep 在循环执 行后面的字符串指令时，[e]si 和[e]di 根据使用的字符串搬运指令，自动加上所搬运数据的字节大小，这是 由 CPU 自动完成的，不用人工干预。比如，执行一次 movsd，[e]si 和[e]di 就自动加 4，执行一次 movsb，[e]si 和[e]di 就自动加 1。有清除方向标志位就会有设置方向标志位，std 是 set direction，该指令是将方向标志位 DF 置为 1，每次 rep 循环执行后面字符串指令时，[e]si 和[e]di 自动减去所搬运数据的字节大小。`







call   ret指令若返回错误，很大部分原因是栈被破坏，因为栈中存在ret返回的地址，我用了bx 16位的寄存器在实模式下在内存中加载，即mov [bx],ax 这是有问题的，当加载的数据过大时，由于bx提供的范围是0~0xffffh，如果加载的数据超过64KB则会使得bx化为0，从0开始加载，若更过大，则会覆盖栈的0x900的位置导致栈被破坏，返回的程序出现错误。所以用ebx
