## 13：中断

**中断分为外部中断和内部中断。**

##### 外部中断

外部中断是指来自 CPU 外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断。比如说网卡收到了来自网络的数据包，这时候网卡就会主动通知 CPU，CPU 得到通知后便将数据拷 贝到内核缓冲区。

为了让CPU获得每个外部设备的中断信号，所有外设中断信号都共享公共线路连接到CPU

**外部硬件的中断是通过两根信号线通知 CPU 的，这两根信号线就是 INTR（INTeRrupt）和 NMI（Non Maskable Interrupt）**

![image-20220715200041127](D:/TYPIC/image-20220715200041127.png)



外部中断分为可屏蔽中断和不可屏蔽中断

`可屏蔽中断是通过 INTR 引脚进入 CPU 的，外部设备如硬盘、网卡等发出的中断都是可屏蔽中断。 可屏蔽的意思是此外部设备发出的中断，CPU 可以不理会，因为它不会让系统宕机，所以可以通过 eflags 寄存器的 IF 位将所有这些外部设备的中断屏蔽。另外，这些设备都是接在某个中断代理设备的，通过该 中断代理也可以单独屏蔽某个设备的中断。对于这类可屏蔽中断，CPU 可以选择不用理会，甚至，即使在理会后，也可以像 Linux 那样，把中断 分为上半部和下半部分开处理，即把非常需要及时处理的分为上半部分，不重要的分为下半部分。所以上半部是在关中断不被打扰的情况下执 行的。当上半部执行完成后就把中断打开了，下半部也属于中断处理程序，所以中断处理程序下半部则是 在开中断的情况下执行的，如果有新的中断发生，原来这个旧中断的下半部就会被换下 CPU，先执行新 的中断处理程序的上半部，等待线程调度机制为旧中断处理程序择一日期（就是指调度算法认为的某个恰 当时机）后，再调度其上 CPU 完成其下半部的执行`



`不可屏蔽中断是通过 NMI 引脚进入 CPU 的，它表示系统中发生了致命的错误，它等同于宣布：计算 机的运行到此结束了.不可屏蔽代表不可控制，无法管理，机器立即崩溃。`

可屏蔽中断并不会导致致命问题，它的数量是有限的，所以每一种中断源都可以获得一个中断向量号。 而不可屏蔽中断引起的致命错误原因有很多，每一种都是硬伤，出现了基本上可以认为用软件解决不了， 多数属于物理上的问题，只能找硬件工程师解决了。所以，既然用软件解决不了，而且每种原因对于软件 工程师来说都意义不大，就没必要再细分原因，统统为导致宕机的各种原因分配一个中断向量号就足够了， 所以不可屏蔽中断的中断向量号为 2。



###### 内部中断

内部中断可分为软中断和异常。

**软中断**，就是由软件主动发起的中断，**因为它来自于软件**，所以称之为软中断。由于该中断是软件运 行中主动发起的，所以它是主观上的，并不是客观上的某种内部错误。

软中断有：

```asm
int 8位立即数   这是我们以后常用的指令，我们要通过它进行系统调用，8 位立即数可表示 256种中断，这与处理器所支持的中断数是相吻合的。



int3 这可不是 int 空格 3，它们之间无间隙。int3 是调试断点指令，其所触发的中断向量号是 3，以后在中断和异常表中大家会看到。我们用 gdb 或 bochs 调试程序时，实际上就是调试器 fork 了一个子进程，子进程用于运行被调试的程序。调试器中经常要设置断点，其原理就是父进程修改了子进程的指令，将其用 int3指令替换，从而子进程调用了 int3 指令触发中断。用此指令实现调试的原理是 int3 指令的机器码是 0xcc，断点本质上是指令的地址，调试器（父进程）将被调试进程（子进程）断点起始地址的第 1 个字节备份好之后在原地将该指令的第 1 字节修改为 0xcc。这样指令执行到断点处时，会去执行机器码为 0xcc 的 int3 指令，该指令会触发 3 号中断，从而会去执行 3 号中断对应的中断处理程序，由于中断处理程序在运行时也要用到寄存器，为了保存所调试进程的现场，该中断处理程序必须先将当前的寄存器和相关内存单元压栈保存（提醒，当前寄存器和相关内存都属于那个被调试的进程），用户在查看寄存器和变量时就是从栈中获取的。当恢复执行
所调试的进程时，中断处理程序需要将之前备份的 1 字节还原至断点处，然后恢复各寄存器和内存单元的值，修改返回地址为断点地址，用 iret 指令退出中断，返回到用户进程继续执行



into  这是中断溢出指令，它所触发的中断向量号是 4。不过，能否引发 4 号中断是要看 eflags 标志寄存器中的 OF 位是否为 1，如果是 1 才会引发中断，否则该指令悄悄地什么都不做，低调得很。



bound   这是检查数组索引越界指令，它可以触发 5 号中断，用于检查数组的索引下标是否在上下边界之内。该指令格式是“bound 16/32 位寄存器， 16/32 位内存”。目的操作数是用寄存器来存储的，其内容是待检测的数组下标值。源操作数是内存，其内容是数组下标的下边界和上边界。当执行 bound 指令时，若下标处于数组索引的范围之外，则会触发 5 号中断



ud2       未定义指令，这会触发第 6 号中断。该指令表示指令无效，CPU 无法识别。主动使用它发起中断，常用于软件测试中，无实际用途。
```

**异常**，异常是另一种内部中断，是指令执行期间 CPU 内部产生的错误引起的。

并不是所有的异常都很致命，按照轻重程度，可以分为以下三种。

`（1）Fault，也称为故障。这种错误是可以被修复的一种类型，属于最轻的一种异常，它给软件一次“改 过自新”的机会。当发生此类异常时 CPU 将机器状态恢复到异常之前的状态，之后调用中断处理程序时， CPU 将返回地址依然指向导致 fault 异常的那条指令。通常中断处理程序中会将此问题修复，待中断处理 程序返回后便能重试。最典型的例子就是操作系统课程中所说的缺页异常 page fault，话说 Linux 的虚拟内 存就是基于 page fault 的，这充分说明这种异常是极易被修复的，甚至是有益的。`

 `（2）Trap，也称为陷阱，这一名称很形象地说明软件掉进了 CPU 设下的陷阱，导致停了下来。此异 常通常用在调试中，比如 int3 指令便引发此类异常，为了让中断处理程序返回后能够继续向下执行，CPU 将中断处理程序的返回地址指向导致异常指令的下一个指令地址。`

 `（3）Abort，也称为终止，从名字上看，这是最严重的异常类型，一旦出现，由于错误无法修复，程 序将无法继续运行，操作系统为了自保，只能将此程序从进程表中去掉。导致此异常的错误通常是硬件错误，或者某些系统数据结构出错。 某些异常会有单独的错误码，即 error code，进入中断时 CPU 会把它们压在栈中，这是在压入 eip 之 后做的，以后会说到，目前先了解下就行`





