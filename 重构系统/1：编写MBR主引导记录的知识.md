## 编写MBR主引导记录，开始掌权

###### 一.一些说明

CPU的硬件电路被设计成只能运行处于内存中的程序，这是硬件基因的问题，其原因是首先内存比较快且容量大，其次由于各个硬件特性不同，若被设计成运行硬件里的程序则操作系统要分别考虑每种硬件特性才行，为了达到统一，故选择只运行内存中的程序。**其次内存不仅仅是DRAM，即内存不仅仅是主板上的内存条（物理内存），包括外设的ROM等。**

载入内存分为两部分：第一部分是程序被加载器（软件或硬件）加载到内存的某个区域，第二部分是设置CPU的CS:IP寄存器指向这个程序的起始地址。



**上面说过，主板上的物理内存不是它眼里的“全部的内存”。**计算机中，并不是只有咱们插在主板上的内存条需要通过地址总线访问，还有一些外设同样是需要地址总线来访问的。若把全部的地址总线用来指向物理内存那么其他设备访问不了。由于这个原因只好在地址总线上提前预留出来一些地址空间用于存放这些外设，比如把连续的地址分配给显存，连续的地址分配给硬盘控制器等。留够了以后，地址总线上其余的可用地址再指向DRAM，也就是指插在主板上的内存条，我们眼中的物理内存。

![image-20220629120349996](D:/TYPIC/image-20220629120349996.png)

这也即是为什么电脑安装了8G，却显示7.8G的原因。



总之，表示地址的那串数字是地址总线的输入，相当于其参数，和内存条没关系。**CPU能够访问一个地址，这是由于地址总线给的映射**。**相当于对该地址分配了一个存储单元**。而该单元要么落在某个ROM上，要么落在物理内存条上，要么落在了某个外设的内存中。



**二.关于磁盘的一些说明**

“0 盘”说的是 0 磁头，因为一张盘是有上下 两个盘面的，一个盘面上对应一个磁头，所以用磁头 Header 来表示盘面。“0 道”是指 0 柱面，柱面 Cylinder 指的是所有盘面上、编号相同的磁道的集合，形象一点描述就是把很多环叠摞在一起的样子，组合在一起 之后是一个立体的管状。“1 扇区”才是我们要解释的部分，将磁道等距划分成一段段的小区间，由于磁 道是圆形的，确切地说是圆环，这些被划分出来的小区间便是扇形，所以称为扇区。



###### 三.BIOS基本输入输出系统



从主机上按下POWER键后，第一个运行的软件是BIOS（基本输入输出系统）。BIOS主要工作是**检测**，**初始化硬件**，怎么初始化的？硬件自己提供了一些初始化的功能调用，BIOS直接调用即可。**不仅如此，BIOS还做了一个很重要的事，填写了中断向量表**，这样就可以通过“int 中断号”来实现相关的硬件调用，当然BIOS建立的这些中断功能就是对硬件IO操作，也即输入输出。但是BIOS总共只有64KB，不可能把所有硬件的IO实现做的面面俱到，而且也没必要实现那么多因为在实模式下，对硬件支持得再丰富也是白搭，精彩的世界是进入保护模式以后才开始的，所以挑选一些重要的基本IO操作即可，**这也是为什么称其为基本的原因**。

BIOS如何启动的？因为BIOS是计算机上的第一个启动的软件，它不可能自己加载自己。由此可知道，它是由硬件加载的。这个硬件便是只读存储器ROM（硬件本身有一定的功能），**此后，BIOS便被写入到该ROM中去，ROM也是块内存，于是被映射到低端的1MB处即0xf0000~0xfffff处，此后CS:IP被强制设置为0xf000:0xfff0(无论如何只要处理完后的地址是0xffff0即可为该16B为BIOS的入口地址)**。只要访问该区间内的地址（映射所对应的存储单元，该映射是由硬件系统完成的）便是访问BIOS系统。

![image-20220629122429864](C:/Users/25238/Desktop/%E2%99%A5%E2%9C%8D/%E9%87%8D%E6%9E%84%E7%B3%BB%E7%BB%9F/image-20220629122429864.png)



另外，因为 cs 和 ip 寄存器中存储的是下一条要执行的指令，目前还没有执行，也就是说，当前还没有 执行 BIOS，这是机器刚开机的那一刻。接下来BIOS就开始尽其责了，检测内存，显卡外设等，并初始化好硬件，开始在内存0x000~0x3ff处建立数据结构，中断向量表IVT并填写中断例程。



**BIOS 最后一项工作**校验启动盘中位于 0 盘 0 道 1 扇区的内容。如果此扇区末尾的两个字节分别是魔数 0x55 和 0xaa，BIOS 便认为此扇区中确实存在可执行的程序（在此先剧透一下，**此程序便是久闻大名的主引导记录 MBR**,MBR位于磁盘上最开始的那个扇区），便加载到物理地址 0x7c00，随 后跳转到此地址，继续执行，如果此扇区的最后 2 个不是 0x55 和 0xaa，即使里面有可执行代码也无济于事了，BIOS 不认。

那么会有两个疑问MBR为什么规定在为什么是 0 盘 0 道 1 扇区？为什么要加载到 0x7c00，而不是个好记或好看的其他地址？

第一个问题：我自行猜测很可能是为了约定，因为如果不告诉BIOS系统MBR在哪？BIOS系统会一遍遍的遍历所有硬盘直到碰见了0x55和0xaa两个魔数才知道是MBR所在位置，这样不如直接索性规定MBR在开始的扇区（可以是任意扇区，只要是固定位置即可），告诉BIOS系统 MBR在哪？这样方便很多

第二个问题：个人计算机肯定要运行操作系统，在这台计算机上，运行的操作系统是 DOS 1.0，不清楚此系统要求 的最小内存是 16KB，还是 32KB，反正 PC 5150 BIOS 研发工程师就假定其是 32KB 的，所以此版本 BIOS 是按最小内存 32KB 研发的。**很简单，MBR首先其安装不能覆盖已有数据，其次也要避免自己的数据过早被覆盖**（通常，MBR 的任务是加载某个程序<这个程序一 般是内核加载器，很少有直接加载内核的>到指定位置，并将控制权交给它。所谓的交控制权就是 jmp 过去而已。之后 MBR 就没用了，被覆盖也没关系。过早的覆盖指的是不被其加载的程序如内核加载器，使得内核加载器加载内核覆盖到自己的空间）。所以我们打个比方，比如说一个操作系统如DOS1.0要求内存至少要32KB，MBR希望给DOS留下更多的预留空间，这也是保全自己避免自己被过早覆盖,MBR 本身也是程序，是程序就要用到栈，栈也是在内存中的，MBR 虽然本身只有 512 字节，但还要为其 所用的栈分配点空间，所以其实际所用的内存空间要大于 512 字节，估计 1KB 内存够用了。结合以上三点，选择32KB中的最后1KB最为合适，那此地址是多少呢？32KB换算为十六进制为0x8000， 减去 1KB(0x400)的话，等于 0x7c00。 （存点疑问）





