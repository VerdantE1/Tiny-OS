# 保护模式

###### 为什么要有保护模式？

```我
1.实模式下操作系统和用户程序属于同一特权级，用户程序可以自由修改段基址，可以随时访问内存
2.用户程序所引用的地址都是指向真实的物理地址，也就是说其逻辑地址等于物理地址，实实在在指哪打哪
以上两个原因是安全缺陷

3.访问超过64KB的内存区域要切换段基址，麻烦
4.一次只能以运行一个程序，无法充分利用计算机资源
5.只有20条地址线，最大可用内存为1MB，不够用
3，4是使用方面的缺陷，5是硬伤
```

为了克服这种低劣的内存管理方式，于是处理器厂商开发了保护模式。这样，物理内存不能直接被程序访问，程序内部的地址（虚拟地址）需要被转化为物理地址后再去访问，程序本身对此一无所知。

顺便说一句，**地址转换是由处理器和操作系统共同协作完成的，处理器在硬件上提供地址转换部件，操作系统提供转换过程中所需要的页表。**



`32 位 CPU 具有保护模式和实模式两种运行模式，可以兼容实模式下的程序。兼容实模式，是指能够 正确处理好实模式下的程序，并不是说在实模式下运行时就完全变成了纯 16 位的 CPU。就像中学生做小 学生的题一样，可以用小学生的知识方法来做，但并不要求自己退化成小学生的知识水平。如果不强调方 法，甚至可以用中学知识来解小学生问题。`





## 保护模式之寄存器扩展

CPU发展到了32位也要向下兼容，内存寻址空间上去了，内存寻址方式还得兼容老办法，即“段基址：段内偏移地址”，寄存器可以用来指定段内偏移地址，还是16位就无法承担4GB寻址的责任。所以寄存器也得跟上宽度。所以除了段寄存器外，统用寄存器，指令指针寄存器，标志寄存器都由原来的16位扩展成了32位。

![image-20220704161558377](D:/TYPIC/image-20220704161558377.png)

**为什么段寄存器还是16位？**





偏移地址还是和实模式一样，但段基址可不是简单的地址的事了，为了更加安全，需要对内存的段进行一些属性维护管理，即维护约束条件，这些信息很多，光靠寄存器事存储不过来的，所以放在内存中专门放了一个数据结构即全局描述符表，用一个GDTR寄存器指向它即可，这样，段寄存器中保存的不再是段基址了，里面保存的内容叫选择子，选择子相当于一个数，用该数索引全局描述符表中的段描述符，其中表中每一项叫做段描述符大小为64B，把GDT当作一个数组，选择子就相当于下表。

然而CPU访问内存不是一件很快的事，段描述符的格式也很奇怪，一个数据要分三个地方存，所以CPU整理这些数据也是得花时间的，如此耗费时间，CPU是等不了的，于是重点来了，为了提高获取信息的效率，对段寄存器率先应用了缓存技术，将段信息用一个寄存器来缓存，这就是段描述符缓冲寄存器。对程序员来说它是不可见的

下面列出三种段描述符缓冲寄存器结构

![image-20220704163934416](D:/TYPIC/image-20220704163934416.png)

base即为段基址。1985年推出了32位CPU80386，地址总线和寄存器都是32位，地址总线支持了32位的内存寻址空间，寄存器32位支持了段内偏移量访问32位地址的能力，**开启了平坦模式**。

## 保护模式之寻址扩展

实模式下的寄存器有固定的使命，对于寻址来说，若想用其他的寄存器编译这关都过不了，如这句代码“mov ax，[dx]”，nasm 编译器会报：error： invalid effective address。

`在保护模式下，这一切都不同了，同样是内存寻址中，基址寄存器不再只是 bx、 bp，而是所有 32 位的通用寄存器，变址寄存器也是一样，不再只是 si、di，而是除 esp 之外的所有 32 位 通用寄存器，偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子，注意比例因子只能是1，2，4，8`

用一个图展示

<img src="D:/TYPIC/image-20220704165405379.png" alt="image-20220704165405379" style="zoom:150%;" />





## 保护模式之运行模式反转



bits 伪指令用于指定运行模式

操作数大小反转前缀 0x66 和寻址方式反转前缀 0x67，用 于临时将当前运行模式下的操作数大小和寻址方式转变成另外一种模式下的操作数大小及寻址方式

例子：

![image-20220704173119266](D:/TYPIC/image-20220704173119266.png)

用以区别指令是针对保护模式还是实模式

## 保护模式之指令扩展

在 16 位的实模式下，CPU 的操作数是 16 位。在 32 位的保护模式下，操作数扩展到了 32 位，于是 涉及到操作数变化的指令也要跟着扩展，既要兼容 16 的操作数，也要支持 32 位的操作数。

扩展时有的命令是在一个寄存器中扩展，有的是新增了寄存器来扩展（如mul,div）。16位的实模式下，CPU照样可以处理32位数据，不是说转换为实模式后CPU退化变成了16位。

`如push，对于段寄存器的入栈，即 cs、ds、es、fs、gs、ss，无论在哪种模式下，都是按当前模式的默认操作 数大小压入的。例如，在 16 位模式下，CPU 直接压入 2 字节，栈指针 sp 减 2。在 32 位模式下，CPU 直 接压入 4 字节，栈指针 esp 减 4。`

`对于通用寄存器和内存，无论是在实模式或保护模式：`

`y 如果压入的是 16 位数据，栈指针减 2`
`y 如果压入的是 32 位数据，栈指针减 4`

`y如果压入的是8位数据，则栈根据该模式是实模式还是保护模式进行对齐后压栈`