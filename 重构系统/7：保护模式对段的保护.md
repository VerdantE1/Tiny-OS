## 保护模式对段的保护

段界限表示段边界的扩展最值，即最大扩展到多少最小扩展到多少，其本质是一个偏移量。

段界限=段大小/单位-1（因为段界限是由0开始算的，即描述符中表示的段界限是9，其实是实际是10）

故实际的边界值=（描述符中段界限+1）*（段界限的粒度大小：4KB 或者 1）-1（由于地址也是从0开始的故算出来的地址也要减1）。







###### 向段寄存器加载选择子保护

保护模式下，引用一个内存段就相当于引用了一个选择子。为了避免非要引用内存段的情况，在这时候，处理器会做出相应的检查。首先根据选择子的值验证段描述符是否超越界限，首先处理器得保证选择子是正确的，判断的标准是选择子的索引值一定要小于等于 描述符表（GDT 或 LDT）中描述符的个数，也就是说，段描 述符的最后 1 字节一定要在描述符表（GDT 或 LDT）的界限地址之内。

过程是：处理器先检查 TI 的值，如果 TI 是 0，则从全局描述符表寄存器 gdtr 中拿到 GDT 基地址和 GDT 界限值。如果 TI 是 1，则从局部描 述符表寄存器 ldtr 中拿到 LDT 基地址和 LDT 界限 值。有了描述符表基地址和描述符表界限值后，把 选择子的高 13 位代入上面的表达式，若不成立， 处理器则抛出异常。注意GDT的0号段描述符是不可引用的。

段描述符中还有个 type 字段，这用来表示段的类型，也就是不同的段有不同的作用。在选择子检查过后，就要检查段的类型了。

![image-20220706155618471](D:/TYPIC/image-20220706155618471.png)

检查完 type 后，还会再检查段是否存在。CPU 通过段描述符中的 P 位来确认内存段是否存在，如果 P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选 择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0， 则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了。 这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并 将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。



###### 代码段和数据段的保护

对于代码段和数据段来说，CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。实际的段界限大小，是段内最后一个可访问的有效地址。由于有了段界限的限制，我们给 CPU 提交的每 一个内存地址，无论是指令的地址，还是数据的地址，CPU 都要帮我们检查地址的有效性。首先地址指向的 数据是有宽度的，CPU 要保证该数据一定要落在段内，不能“骑”在段边界上。

`举个例子，假设数据段描述符的段界限是 0x12345，段基址为 0x00000000。 如果 G 位为 0，那么实际段界限便是 0x12345。如果 G 位为 1，那么实际段界限便是 0x12345*  0x1000+0xFFF=0x12345FFF。如果访问的数据地址是 0x12345FFF，还要看访问的数据宽度。若数据大小是 1 字节，如 mov ax，byte [0x12345fff]，这种内存操作一点问题都没有，数据完全在实 际段界限之内。 若该数据大小是 2 字节，如 mov ax，word [0x12345fff]，这种内存操作超过了实际的段界限，数据所 在地址分别是 0x12345FFF 和 0x12346000 这两个字节，CPU 会抛异常。`





###### 栈段的保护