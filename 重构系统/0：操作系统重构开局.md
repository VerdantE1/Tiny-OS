## 操作系统重构开局

**首先第一，相信上层提供的服务。**既然学操作系统是软件层，不必纠结于硬件内部是如何工作的，我们只认为给硬件一个输入，硬件就会给我们一个输出就行。



**第二，操作系统就是像部落，提供工具等管理**。



##### 硬件简述：

硬件输入输出大体分为串行和并行，相应的接口也就是串行接口和并行接口。硬件都是将其内存空间映射到一定的范围地址空间中，CPU通过地址总线访问该内存。



访问外设硬件有两个方式：1.内存映射；2.通过IO接口（寄存器）访问



##### 真正理解用户态和内核态：

用户态和内核态是相对CPU来讲的，是指CPU运行在用户态（特权3级）还是内核态（特权0级），不是相对用户进程来讲的。用户进程进入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被保存在自己的0级特权栈中了，此时CPU是在运行内核程序了。所以要清楚，内核代码并不是成了应用程序的内核化身，操作系统是独立的部分，用户进程永远不会因为进入内核态而变身为操作系统了。



##### 内存访问为什么要分段？

最开始内存是不分段的，也就只有绝对物理地址的存在，想象一下，如果两个程序用到了同一绝对物理地址，那么最后写入到内存中都会占用同样的地址，那么两个程序只能正确运行一个，这个时候，我们可以想办法用一种重定位的思想去解决，于是一种相当于CPU访问内存的交通系统的存在出现了即段基址+段内偏移地址出现了。

![image-20220626023251032](D:/TYPIC/image-20220626023251032.png)

**CPU若采用“段基址+段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器,这些是cs,ds,es等用来维护段这个数据结构**，程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移 地址便可，CPU 中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。 段基址和段内偏移地址可以通过合适的组合（可能不唯一）去确定绝对物理地址。**这是用到分段的第一个原因即**：**方便重定位**。 有了段才有资本实施重定位，就如有了交通系统（公路）你才能运用机车。

**其二，程序分段又是为了将大内存分成可以访问的小段， 通过这样变通的方法便能够访问到所有内存了**。这是如何实现的呢？如果用绝对物理地址，那么寄存器的位数可能真的达不到访问全部内存地址，于是我们可以通过两个寄存器进行一部分组合运算并节合段这个数据结构来生成绝对地址数供CPU访问（当然也可以在程序中用立即数但是这是得靠程序员软实力不能靠机器自动化）。比如16位要访问20位的内存，将段基址乘以16，即左移了4位，然后再和 16 位的段内偏移地址相加，这下地址变成了 20 位了。





一般的高级语言不允许程序员自己将代码分成各种各样的段，**这是因为编译器是针对操作系统编写的**，若该操作系统采用的是平坦模型，所以该编译器要编译器出适合此操作系统加载运行的程序。**编译器规划用户写的代码，并进行分段。**但是，汇编语言却可以让用户自己规划空间分配，汇编器为各种变量进行分配空间赋址。





###### CPU如何能源源不断地获取到指令？

首先由于指令是连续紧凑的，其次是能通过机器码能够判断当前指令长度，当前指令地址+当前指令长度=下一条指令地址。连续紧凑指的是逻辑上连续就可以，没必要一定得是物理上连续，最典型的就是用jmp跳过数据区。





**区分代码段和数据段的原因？**

1.可以赋予不同的属性：例如数据本身是需要修改的，所以数据就需要有可写，而程序中的代码是不能被更改的，这就要求代码段只具备只读的属性。

2.为了提高CPU内部缓存的命中率：缓存器作用的原因是程序的局部性原理。在CPU内部也有缓存机制，将程序中的指令和数据分离，这有利于增强程序的局部性。CPU内部有针对数据和针对指令的两种缓存机制，因此，将数据和代码分开存储将使程序运行的更快

3.节省内存：程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时没必要在内存中同时存在多个相同的代码段，如果不分代码段，那么代码数据混在一起很难找到代码是哪些，难维护，而代码段和数据段的区分使得易于维护代码段，因此只要把这个代码共享即可，达到节省内存。





**如何给段画上只读或者只写等不同的属性？**

编译器负责挑选出数据并划分出各种段，并没有为段画上属性，CPU保护模式支持一种GDT全局描述符表这种数据结构。操作系统通过设置GDT全局描述符表来构建段描述符，在段描述符中指定段的位置，大小以及属性。赋予段的属性，最后CPU根据GDT去判断段的属性。





**程序分段和内存分段？**

程序分段是软件中人为逻辑划分的内存区域，它本身也是内存，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始位置。





**虚拟地址，线性地址，物理地址**

![image-20220626154521238](D:/TYPIC/image-20220626154521238.png)

**CPU实模式下的内存访问采用段机制，保护模式下采用平坦模型**



**局部变量和函数参数为什么要放在栈中？**

第一，函数调用是动态调用。函数在编译阶段根本无法确定它会被调用几次，其参数和函数返回的地址都要用内存存储，所以也不知道其会需要多少内存。提前把内存分配给目前并不使用内存的进程，而眼前需要内存的程序徐若无内存可用这是不可取的。第二，局部性，只有这个函数用这个参数，何必将其放在数据段呢。





###### 编译型程序与解释型程序的区别

解释性程序其本质是文本，是对于解释器来的，这个解释器就是一个进程，和一般的进程是没有区别的，只是这个进程的输入则是一些文本脚本，根本不是什么指令或代码之类。只是这种解释器了解这种语法，按照语法规则来输出罢了。而编译型程序则是将程序编译成指令，CPU去执行。





**BIOS中断，DOS中断，Linux中断的区别**

BIOS和DOS都是存在实模式下的程序，**由它们建立的中断调用**都是建立在中断向量表中的，这个中断向量表就如同上述写的GDT一样，都是由CPU原生提供的，由BIOS等系统填写。它们都是通过软中断指令int 中断号来调用的。中断向量表中的每个中断向量大小为4字节，这4个字节描述了中断处理例程的段基址和段内偏移地址。**计算机启动之初，中断向量表的中断例程是由BIOS建立的，它从物理地址0x0000处开始初始化并在中断向量表中添加各种例程**。BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。

DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，**只不过其中断向量号和 BIOS 的不能冲突。**DOS 中断只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程，**DOS 中断调用中那么多功能是如何实现的？**是通过先往 ah 寄存器中写好子功能号，再执行 int 0x21。 这时在中断向量表中第 0x21 个表项，即物理地址 0x21*4 处中的中断处理程序开始根据寄存器 ah 中的值 来调用相应的子功能，**说白了就是一个例程中有许多子功能**。

 而Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了， 取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。所以在 Linux 下执行的中断调用，访问的中断例程是在中断描述符表中，已不在中断向量表里了。**Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。**再补充一句：如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。





```cpp
（也表明也可以不通过BIOS系统访问硬件，但是比较难，操作硬件无非是通过 in/out 指令来读写外设的端口，BIOS 中断程序处理是用来操作硬件的，故 该处理程序中一定到处都是 in/out 指令）。
```

每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS 就存放 在里面），不过这种内存都是只读存储器 ROM。硬件自己的功能调用例程及初始化代码就存放在这 ROM 中。根据规范，第 1 个内存单元的内容是 0x55，第 2 个存储单元是 0xAA，第 3 个存储单位是该 rom 中以 512 字节为单位的代码长度。从第 4 个存储单元起就是实际代码了，直到第 3 个存储单元所示的长度为止。

**那么既然是ROM，CPU如何去访问该ROM内存呢？**

访问外设有两种方式（1）内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）。 （2）端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存

从内存的物理地址 0xA0000 开始到 0xFFFFF 这部分内存中，一部分是专门用来做映射的，如果硬件 存在，硬件自己的 ROM 会被映射到这片内存中的某处，至于如何映射过去的，咱们暂时先不要深入了， 这是硬件完成的工作





总体而言，操作系统启动时工作在实模式，此时有BIOS调用。之后根据引导扇区，进行系统引导。一个操作系统的实现实验里，使用引导扇区装载loader。然后loader装载内核，以上都在实模式。

然后loader在装载内核到内存后跳入保护模式。此后都在保护模式，而之后的用户态和内核态是在保护模式而言的。可以使用内核调用（dos调用）



**BIOS为什么要添加中断程序例程呢？**

（1）给自己用，因为 BIOS 也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写 成中断函数，直接调用多省心 （2）给后来的程序用，如加载器或 boot loader。它们在调用硬件资源时就不需要自己重写代码了





 **Section 和 Segment 的区别**

首先汇编器根据语法规则，会将汇编源码中表示“节”的语法 关键字 section 或 segment 在目标文件中编译成“节”，此“节”便是我们要讨论的 section。经过汇编生成目标 文件之后，由这些 section 或 segment 修饰的程序区域便成为了“节”（section）。链接器将目标文件中属性相同的节合并成一个大的 section 集 合，此集合便称为 segment，也就是段，此段便是我们平时所说的可执行程序内存空间中的代码段和数据段。





###### 小序和大序

小端字节序是数值中的低位在低地址（低地址是前面，即低的在前面），高位在高地址（高地址是后面，即高的在后面），数位以字节为单位。

大端字节序是数值中的低位在高地址即右边，高位在低地址，就像人正常理解的一样。

![image-20220627170709440](D:/TYPIC/image-20220627170709440.png)



![image-20220627170850485](D:/TYPIC/image-20220627170850485.png)



###### 指令集和微架构

指令集是具体的一套指令编码，微架构是指令集的物理实现方式。而CISC（Complex Instruction Set Computer）和RISC（Reduced Instruction Set Computer）是两个流派。为什么手机上的应用软件在电脑上运行不了？首先指令架构不同一个是x86一个是ARM，有不同的语法，很显然电脑上汇编器汇编的机器码在手机上是无法运行的，手机的处理器无法识别电脑上的语法，指令集不同就无法识别。并且OS不同，接口就不同，应用层软件的端口的接口在不同的系统上是无法识别的。CPU 与指令集是对应的，一种 CPU 只能识别一种指令集，所以很多 CPU 都以其支持的指令集来称呼。 比如 ARM、MIPS，它们本身是 CPU 名称，又是指令集名称。



**交叉编译**

交叉编译，本质上交叉编译就是用在 A 平台上运行的编译器，编译出符合 B 平台 CPU 指令集的程序，编译出的程序直接能在 B 平 台上运行啦。这里的平台指的就是 CPU 指令体系结构





###### 函数声明的作用

（1）函数返回值类型、参数类型及个数，用来确定分配的栈空间。 

（2）该函数是外部函数，定义在其他文件，现在无法为其分配地址，需要在链接阶段将该函数体所在的目标文件一同链接时再安排地址





**库函数是用户进程与内核的桥梁**

include 指令不关心所包含的 文件名是啥，只是原方不动地将所包含的文件内容在此处展开。我们在程序中简单地一句 include <标准头文件>之所以有效，是因为编译器提供 的 C 运行库中已经为我们准备好了这些标准函数的函数体所在的目标文件，在链接时默默帮我们链接上了。

（1）.每个操作系统有自己支持，加载用户进程的规则，而C运行时库（CRL）是针对此操作系统规则，为了让用户程序开发更容易，用来支持用户进程的代码库。

（2）.C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工作，所以即使不包含标准库文件，链接阶段也要用到 c 运行时库。

（3）.尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效

（4）用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过该OS提供的系统调用。操作系统也是一种软件，提供人与硬件交流的简便方法，想用或不用在于你。
