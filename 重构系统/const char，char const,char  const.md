### const char`*`，char const`*`,char `*` const

**const char \***与**char const \*** 效果一样，**都是不允许修改指针指向的地址空间的值，即把值作为常量**，而**char \* const**则是不允许修改指针自身，不能再指向其他地方，**把指针自己当作常量使用**。需要注意的是，使用**char \* const** 定一个常量指针的时候一定记得赋初始值，否则再其他地方就没法赋值了



##### 文字常量

文字常量又称为“符号常量”，**经编译之后写在代码区，是不可寻址的。而常变量同其它变量一样被分配空间，是可以寻址的**

```cpp
int& r=5;   //编译错误 ,文字常量不可寻址，因而无法为文字常量进行建立引用。而下面这条是合法的
const int& r=5;    //原因是编译器将一个文字常量转化成常变量的过程。在数据区开辟了一个值为5的无名整型常变量。然后将引用r与这个整型常变量进行绑定。所以这条语句实际上表达的意思是开辟了一个新的常变量与r绑定	
```





文字常量包括数值常量、字符常量和符号常量，其特点就是编译后写在代码区，不可寻址，不可更改

如整型常量456，789，实型常量1.65，字符型常量'a'文字常量是指可直接使用的常量。

程序中有些特殊的标识符或表达式由于满足文字常量的两个条件：不可寻址、不可改变，也可以将它们视为文字常量。它们分别是：静态数组名、枚举常量、全局（静态）变量首地址



##### 常变量

如果一个常量在定义它的时候就给他赋初值，且此后它的值就不能被改变，那么这个变量就是常变量

常变量由普通变量前添加const关键字来定义

常变量的值在赋值后不能被改变并不是真的不能改变，而是对于高级语言语法上的限制，**实际上常变量在运行时并不是存放在只读内存区，其存储在可寻址的代码段**，因此只要在程序运行时获取到变量的地址，即可对其进行修改

常量并不是真的不可以改，常量是可以通过找到地址而进行更改，只不过这是一种高级语言的限制，可以通过编译器更改将waring不变成error进行编译。实际上常变量在运行时并不是存放在onlyread内存段，因此只要在程序运行时获取到变量的地址，即可以对其修改。



注意，字符串常量是常变量的一种，名称为其本身，存储在代码段，可寻址，不可修改。、

```cpp
cout<<&”hello world”<<endl; //打印输出字符串常量”hello world”存储地址
```

常变量在C/C++中由const关键字来定义，分为全局常变量和局部常变量。**二者的区别在于：全局常变量存储在代码段的只读内存区域，不可修改有操作系统来保障，局部常变量存储在栈区，在编程语言语义层面上由编辑器做语法检查来保障其值不可修改，因不是放在只读内存中，可以获得局部常变量的地址，运行时间接进行修改**



```c
#include<sdtio.h>

//const int b = 5;  全局常变量
int main(){
    const int b =5;  //局部常变量存储在栈区，编译器语法检查
    int* _b = &b;
    * _b =8;
    
    printf(~ b);
    while(1);
 	return 0;   
}


```



如果是下面那种，则b输出8，如果保留上面全局常变量则会发生段错误（核心已转储），这是由于全局常变量存在onlyread内存段，该段由操作系统来保护，不可访问到该地址，所以调用中断表示出现错误。





最后常变量指针可以自加自减

```c
int main() {

	char b[] = "asdafsaf";
	
	const char* b_ = b;
	b_++;
	while (1);
	return 0;
}
//不会报错
```

