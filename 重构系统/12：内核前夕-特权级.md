## 特权级

![image-20220711131420674](D:/TYPIC/image-20220711131420674.png)



##### 一.TSS简介

TSS，即 Task State Segment，意为任务状态段，**它是处理器在硬件上原生支持多任务的一种实现方**
**式**，也就是说处理器原本是想让操作系统开发厂商利用此结构实现多任务的，人家处理器厂商已经提供了多任务管理的解决方案，尽管后来操作系统并不买账，这是后话，以后再议。

TSS 是一种数据结构，**它用于 存储任务的环境**。咱们一睹为快，

![image-20220711140236819](D:/TYPIC/image-20220711140236819.png)

**TSS 是每个任务都有的结构，它用于一个任务的 标识，相当于任务的身份证，程序拥有此结构才能运行，这是处理器硬件上用于任务管理的系统结构，处理器能够识别其中每一个字段。**



ss0 和 esp0、ss1 和 esp1、ss2 和 esp2？它们分别代表 0 级栈的 段选择子和偏移量、1 级栈的段选择子和偏移量、2 级栈的段选择子和偏移量。



任务是由处理器执行的，任务在特权级变换时，本质上是处理器的当前特权级在变换，由一个特权级 变成了另外一个特权级。每个任务的每个特权级下只能有一个栈，不存在一个任务的某个特权级下存在多个同特权级栈的情况。也就是说，一共 4个特权级，一个任务“最多”有 4 个栈。



特权级转移分为两类：一类是由中断门，调用门等手段实现低特权级转向高特权级，称为向**内核转移**。另外一种则相反，是由调用返回指令从高特权级返回到低特权级，称为**向外层转移**这是唯一一种能让处理器降低特权级的情况。

对于第一种，向内核转移，需要找到高特权级的栈地址，向高特权级转移时需要从中取出来加载到SS以及ESP中以更新栈。这个保存的地方就是TSS。

对于第二种，向外层转移，处理器无需去TSS中找低特权级的栈地址。因为由实现机制决定，高特权级是由低特权级转移过去的，所以高特权级知道低特权级栈地址，即转移高特权级时，低特权级的栈指针自动压入高特权级栈里面，等再回去到低特权级时，自动在高特权级栈里丢弃低特权级的栈选择子和esp指针。

**所以要用到TSS是第一种，向内核转移找到高特权级的栈指针。**

TSS是硬件支持的系统数据结构，它和GDT一样，由CPU支持，由软件填写，由硬件使用TSS如同GDT一样，由TR（task register）寄存器加载的，**每次处理器执行不同的任务时，将TR寄存器加载不同任务的TSS即可**



##### 二.DPL和CPL入门

现在说计算机，既然是用特权级来维护计算机世界的和平，那总该给每个被管理的对象加个特权“标 签”，也就是说 CPU 得知道谁的特权高，谁的特权低，这样才能辨识出是否有低特权级的程序越级访问高 特权级资源的违法行为。

**任何特权级最终针对的是CPU，及CPU是否的当前特权级CPL是否有能力访问。**

位于 CS 寄存器中选择子低 2 位的值不仅称为请求特权级，又称为处理器的当前特权级，也就是说处 理器的当前特权级是 CS.RPL。**在 CPU 中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是代 码段描述符中的 DPL，便是当前 CPU 所处的特权级，这个特权级称为当前特权级。**在任意时刻，当前特权级 CPL 保存在 当前CS 选择子中的 RPL 部分。

**其实只是代码段寄存器 CS 中的 RPL 是 CPL，其他段寄存器中 选择子的 RPL 与 CPL 无关**，因为 CPL 是针对具有“能动性”的访问者（执行者）来说的，代码是执行者， 它表示访问的请求者，所以 CPL 只存放在代码段寄存器 CS 中低 2 位的 RPL 中。

大多数情况下，处理器都是在“访问者”访问“受访者”时进行特权检查，访问者（某个代码段）的特权 就是当前特权级 CPL，在进行特权检查时，都会以 CPL 为基础，访问者任何时候都不允许访问比自己特权更高的资源，无论受访资源是数据，还是代码。



处理器的特权级升高之后，程序想干什么就干什么，多少都觉得有点恐怖，有没有一种好办法，既执行高特权级代码段上的指令，又不提升特权级？一种方式是利用一致性代码段。

什么是一致性代码段？早在当初介绍段描述符结构时就已经提过它了，不过确实只是提了一下而已， 以至于您可能完全没有印象。在段描述符中，如果该段为非系统段（段描述符的 S 字段为 0），可以用 type 字段中的 C 位来表示该段是否为一致性代码段。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该 段为非一致性代码段。第二条所提到的代码段是非一致性代码段，所以只能平级转移。

这说明转移本身并没有提升特权级，只是可以跑到特权级更高的代码中去执行指令，对计算机而言，并未因特权级升高而产生潜在危险，所以在特权级检查过程中，请求者的 RPL 并不参与。





记住：

1.**访问者一定是代码段**

2.**目前CPU指向的指令即目前的CS所寄存的选择子里面的RPL就是当前的CPL**

3**.CPU唯一一种降低特权的方法就是处理器从中断处理程序中返回到用户态**

4.**特权级检查发生在访问者访问受访者的一瞬间，只检查一次**

5.**低特权向高特权转移**   =  **CPU特权转移，指向非一致性代码的RPL赋予CPL**

6.切换的过程，都是要先保留上下文（相关数据存到两个特权栈中），再转移CS:IP，如果是平级转移则不会更新当前栈，用的是同一栈，因为是同一栈，在同一段，当作直接远转移即可。

**7.特权级检查=安检=过了之后就飞天**，**特权级代表CPU有没有资格访问某个资源**

**8.特权级检查只发生在段寄存器重新加载的选择子的时候**

**9.内核有内核自己的代码段，数据段；用户程序有用户程序自己的代码段，数据段**





```cpp
对于数据段来讲，只有访问者的权限大于或等于段描述符中的DPL表示的最低权限时才能够访问。
```

```cpp
对于代码段来讲，只有访问者的权限等于段描述符中的DPL才能访问。即只能平级访问。访问一个代码段实质上就是跳转到这个段进行执行。唯一一种处理器从高特权级降到低特权级执行的情况是处理器从中断处理程序中返回到用户态。
你低特权级的事情，我高特权级能做，还能做的更多，没必要降低特权级，而且不能降低特权
```

```cpp
一致性代码段：一致性代码段也成为依从代码段，用来实现从低特权级的代码向高特权级代码的转移。一致性代码段是指如果自己是转移后的目标段，则自己的特权级一定能要大于等于转移前的CPL，也就是说一致性代码段的DPL是特权的上限。处理器遇到目标端位一致性代码段的时候并不会将CPL用该段的DPL来替换，任何在此权限之下的特权级都可以转到此代码段上执行。代码段可以有一致性与不一致性的段，但是数据段只能有非一致性，即数据段不允许比自己特权级低的代码段访问。
```



##### 三.门

处理器只有通过“门结构”才能由低特权级转移到高特权级，处理器就是这样设计的，我们必须要遵 循它的用法，对处理器来说，操作系统只是它的应用而已。

门结构是什么呢？就是记录一段程序起始地址的描述符。门描述符定义在全局描述符表 GDT 和局部描述符表 LDT 中，所以，要想使用调用门，就要 通过门描述符的选择子。

**共有四种门：任务门，中断门，调用门，陷阱门**

提供了4种门的原因是它们都有各自的应用环境，**但它们的目的都是用来实现从低特权级的代码段转向高特权级的代码段的，提升处理器CPU的特权级。**

门的实现原理，类似蹦床原理

![image-20220711182225324](D:/TYPIC/image-20220711182225324.png)



举个例子说明调用们的过程保护：

```cpp
假设用户进程要调用某个调用门，该门描述符中参数的个数是 2，也就是用户进程需要为该调用门提供 2 个参数才行。调用前的当前特权级为 3，调用后的新特权级为 0，所以调用门转移前用的是 3 特权级栈，调用后用的是 0 特权级栈。
    
    调用调用们需要提供2个参数,目前在特权级3下，先将参数a,b压入3级栈中,处理器自动在TSS中找到转移后合适的栈，得到合适的SS,ESP数值，然后想把该数值加入到SS寄存器中，需要特权级检查，若不合适则报错，若合适，下一步，将旧的SS_old,ESP_old放到一个缓冲区，然后加载SS_new,ESP_new,在使用新栈后，将上一步临时保存得到SS_old,ESP_old压入新栈中，也就是0级栈（注意咱们讨论的是保护模式32位模式，故栈操作数是32位，但是SS是16位，将其高16位填0后入栈保存），再根据SS_old,ESP_old将其原先保存的参数a,b取出压入新栈，再如压入SS_old,ESP_old一样，将CS_old,EIP_old压入新栈，最后如上一样，检查特权级，设置CS,IP指向新的位置。
    
    
    因为处理器是被所有任务共享的，它在不同任务之间来回切换，它根本不知道自己刚刚执行的是哪个任务，更不知道自己是刚刚从低特权级通过调用门过来的。所以程序回到低特权级也要做特权级检查，通过retf重新加载各段，包括特权级检查。
```

![image-20220711193950237](D:/TYPIC/image-20220711193950237.png)

#### 四.RPL引入，完整的特权级保护

如果只靠CPL和DPL，是不安全的，因为内核不知道请求操作的身份是谁，如果是恶意的用户程序会导致仅仅通过门等提升CPL来破坏内核。**所以引入了RPL，指明了真正的要求者是谁。而CPL相当于通过某人的手段,DPL就相当于权限的门槛。**

RPL代表真正请求者的特权级，即真正资源需求者的CPL，请求某特权级为DPL级别的资源时，参与特权检查的不仅仅是CPL，还要加上RPL，即CPL和RPL的特权必须同时大于等于受访者的特权DPL。

**特权级检查发生在加载段选择子访问描述符的那一瞬间，这里的访问指的是无论是访问数据，还是代码**

**在任意时段CPL是由DPL赋予的**

**CPL和RPL是可能来自于不同的程序的**



RPL在选择子中的低2位，而DPL在段描述符的低2位。**当用户程序通过门等想提升特权级请求操作系统服务时，如果需要提交选择子作为参数（一个选择子代表一个段描述符，一个段描述符代表一段内存空间+属性），为安全起见，操作系统会把选择子中RPL改为用户程序的CPL**。用户程序的CPL不会骗人的，不可能伪造，它起始是OS在加载用户程序时赋予的内存空间，该内存空间的段描述符有DPL，CPU在运行该段指令时CPL 被 DPL赋予值。CPL记录在CS中，而就算用户程序将CS更改的话最多只能在3级折腾不可能到更高的特权级（访问到非一致性代码只能同级跳转，访问到一致性代码CPL不会更改，访问到数据段只能低于3级特权级，只要用户不请求操作系统服务CPL是不可能改变的）





人性理解

```shell
不知道大伙儿学车了没有，报考驾校也要有个年龄限制，即使考 C 本 B 本也要分年龄的。假如某个
小学生 A（用户进程）特别喜欢开车，他就是想考个驾照，可驾校的门卫（调用门）一看他年龄太小都不
让他进门，连填写报名登记表的机会都没有，怎么办？于是他就求他的长辈 B（内核）帮他去报名，长辈
的年龄肯定够了，门卫对他放行，他来到驾校招生办公室后，对招生人员说要帮别人报名。人家招生人员
对 B 说，好吧，帮别人代报名需要出示对方的身份证（RPL），于是长辈 B 就把小学生 A 的身份证（现在
小孩子就可以申请身份证，只是年龄越小有效期越短，因为小孩子长得快嘛）拿出来了，招生人员一看，
年纪这么小啊，不到法制学车年纪呢，拒绝接收。这时候驾校招生人员的安全意识开始泛滥了，以纵容小
孩子危险驾驶为名把长辈 B 批评了一顿（引发异常）。
```



#### 五.IO特权级

**在保护模式下，处理器中的“阶级”不仅体现在数据和代码的访问，还体现在指令中。**

一方面将指令分级的原因是有些指令的执行对计算机有着严重的影响，它们只有在 0 特权级下被执 行，因此被称为特权指令（Privilege Instruction）。比如 hlt 指令，它可以让计算机停机，处理器只信任操 作系统，所以它不得不放在 0 特权级下。同类的指令还有 lgdt、lidt、ltr、popf 等，这些对计算机的正常运 行起着非同小可的影响，操作系统只有亲自执行它们才放心。

另一方面体现在 I/O 读写控制上。IO 读写特权是由标志寄存器 eflags 中的 IOPL 位和 TSS 中的 IO 位 图决定的，它们用来指定执行 IO 操作的最小特权级。IO 相关的指令只有在当前特权级大于等于 IOPL 时才 能执行，所以它们称为 IO 敏感指令（I/O Sensitive Instruction），如果当前特权级小于 IOPL 时执行这些指令 会引发处理器异常。这类指令有 in、out、cli、sti。所以你懂的，不只是操作系统可以进行 IO 端口访问，用 户进程也是可以的，只是操作系统不允许用户进程这么做。

**所以用户程序不能访问硬件的原因就是 IO端口被操作系统设立特权级禁止其访问。**



#### **IOPL 与 IO位图**



IPOL位于eflags中，

**每个 任务（内核进程或用户进程）都有自己的 eflags 寄存器，所以每个任务都有自己的 IOPL，它表示当前任 务要想执行全部 IO 指令的最低特权级，也就是处理器最低的 CPL，只有任务的当前特权级大于等于 IOPL 才允许执行全部 IO 指令**

IOPL如何设置呢？用户程序可以由操作系统加载时通过指定整个eflags设置，操作系统如何设置自己的IOPL呢？可惜的是IOPL没有直接读写eflags寄存器的指令，不过可以通过将栈中数据弹出到eflags寄存器中来实现修改。可以先用pushf指令将eflags整体压入栈，然后在栈中修改相应位，再用popf指令弹出到eflags寄存器中。另外一个可利用栈的指令是iretd，用iretd指令从中断返回时，会将栈中相应位置的数据当成eflags的内容弹到elfags寄存器中，所以可以改变eflags的指令只有iret和popf



之前说过，IOPL 是所有 IO 端口的开关，不过，这个开关还留有余地，如果将开关打开，便可以访问 全部 65536 个端口，如果开关被关上，即数值上 CPL > IOPL，则可以通过 IO 位图来设置部分端口的访问 权限。也就是说，先在整体上关闭，再从局部上打开。这有点像设置防火墙的规则，先默认为全部禁止访 问，想放行哪些端口再单独打开。

`什么是驱动程序？  `           

`驱动程序就是通过 in、out 等 IO 指令直接访问硬件的程序，它为上层程序提供对硬件的控制访问，相 当于硬件的代理，程序员通过它就免去了学习硬件控制的相关知识，简化了程序设计。 所以说，驱动程序肯定是要直接控制 IO 端口的，尽管它可以像 Linux 那样位于 0 特权级，但它位于 1 特权级时，依然可以直接操作硬件端口。`

位图就是 bit map，map 就是映射,

![image-20220712084035556](D:/TYPIC/image-20220712084035556.png)

TSS上的IO位图可以组成前8位是63356个数值，最后一位表示是否允许（I/O 位图只是在数值上 CPL > IOPL，即当前特权级比 IOPL 低时才有效，若当前特权级大于等于 IOPL，任何端口都可直接访 问不受限制）

![image-20220712084403143](D:/TYPIC/image-20220712084403143.png)

I/O 位图是位于 TSS 中的，它可以存在，也可以不存在，它只是用 来设置对某些特定端口的访问，没有它的话便默认为禁止访问所有端 口。正是由于它可有可无，所以 TSS 的段界限 TSS limit，即实际大小-1， 并不固定。当 TSS 中不包括 I/O 位图时，TSS 只有 104 字节大小。话说回来了，当处理器执行某些 IO 指 令时，若当前特权级比 IOPL 低，处理器就会认为也许只是给当前任务单独放行了某些端口，于是它就到 TSS 中找 I/O 位图，如果 I/O 位图不存在，即所有端口都禁止访问，于是处理器就会抛异常。当包括 I/O 位图时，其大小是“I/O 位图偏移地址”+8192+1 字节，结尾这个 1 字节是 I/O 位图 中最后的 0xff，



**现在来说下为什么在 IO 位图的结尾有个 0xff**。 在计算机系统硬件中，IO 端口是按字节来编址的，意思是说一个端口只能读写 1 个字节的数据。 如果对一个端口连续读写多个字节，实际上是从以该端口号为起始的多个端口一并读进来的。举个例子， 比如 in 指令可以读取 16 位端口数据，即一次读取 2 字节，假设端口 0x234 是 16 位端口：in ax,0x234 这相当于 in al,0x234  in ah,0x235  其作用是**避免越界访问 TSS 外的内存**，其二，**处理器允许 I/O 位图中不映射所有的端口，即 I/O 位图长度可以不足 8KB**，但位图的最后一字 节必须为 0xFF。如果在位图范围外的端口，处理器一律默认禁止访问。这样一来，如果位图最后一字节 的 0xFF 属于全部 65536 个端口范围之内，字节各位全为 1 表示禁止访问此字节代表的全部端口，
