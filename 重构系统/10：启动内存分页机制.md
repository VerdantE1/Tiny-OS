## 10：启动内存分页机制

启动内存分页之前，CPU认为线性地址等于物理地址。而线性地址是由编译器编译的，它本身是连续的，而CPU又认为线性地址=物理地址，所以因为线性地址是连续的所以物理地址也是连续的。所以内存中的程序是连续的，连续的话就会用碎片问题。

![image-20220707201554554](D:/TYPIC/image-20220707201554554.png)

启动分页系统之后，将线性地址和物理地址通过一种映射关系进行映射，这样就可以高效的解决问题。

操作系统和硬件之间是相互依赖、相互推动、相互促 进而发展起来的。

实现映射的方法有很多，比如可以写个哈希算法，不过这都是软件实现的算法，时间复杂度再低，效率也肯定不如硬件本性支持的快。因为硬件的操作更直接，并且已经在电路上做过优化，而软件的效率主要取决于代码的算法和编译器的优化能力，即使产生处最优化的机器码，也是被当作普通指令处理：先到要内存中取指，译码，再执行，不说别的，光是取值从内存就已经很慢。所以对于地址转换这种实时性较高的要求，CPU已经给予了问最大的硬件支持。在CPU实现中，这种映射关系是通过一张表来实现的，该表就是我们所说的页表，查找页表的工作是由**页部件**完成的。

![image-20220708061951150](D:/TYPIC/image-20220708061951150.png)



分页机制的作用：

![image-20220708062231265](D:/TYPIC/image-20220708062231265.png)

如果地址按一一映射的话，页表也是存储在内存中的，为了表示 32 位地址，每 个页表项必须要 4 字节，若按此方案，光是页表就要占 16GB 内存，得不偿失，显然方案不合理。



![image-20220708064829018](D:/TYPIC/image-20220708064829018.png)



`左图不合理，于是右图来解决。32 位地址表示 4GB 空间，可以将 32 位地址分成高低两部分，低地址部分是内存块大小，高地址部分是 内存块数量，它们是这样一种关系：内存块数*内存块大小=4GB。故我们可以在图 5-10 所示的 32 位地址上滑 动滑块找到合适的内存块尺寸。滑块右边是内存块尺寸，滑块左边是内存块数量。`

这里所说的内存块，其官方名称是**页**，CPU 中采用的页大小恰恰就是 4KB，也就是图 5-10 中滑块的落点处。划分后，内存块尺寸就是页大小。**页是地址空间的计量单位，并不是专属物理地址或线性地址。**



###### 线性地址转化为物理地址的方式： 任意一个地址最终会落到某一个物理页中。32 位地址空间共有 1M（1048756） 个物理页，首先要做的是定位到某个具体物理页，然后给出物理页内的偏移量就可以访问到任意 1 字节的 内存啦。所以，用 20 位二进制就可以表示全部物理页啦。标准页都是 4KB，12 位二进制便可以表达 4KB 之内的任意地址。











#### 一级页表过程：

**页表是存储在内存的**。虚拟地址的高20位是用来索引页表里面的页表项，页表项里面存储的是物理页地址，低12位用来在物理页内寻址。所以问题就变成了怎样用线性地址找到页表中的对应页表项。

`在此之前要注意两件事`

`（1）分页机制打开前要将页表地址加载到控制寄存器cr3中。`

`（2）虽然内存分页机制的作用是将虚拟地址转成物理地址，但其转换过程也是相当于在关闭分页机制下进行，过程中所涉及到的页表及页表项的寻址，它们都被CPU当作最终的物理地址直接送上地址总线，不会被分页机制转换（否则会递归下去）`

分析过后，地址转换过程原理如下：

页表里面有很多页表项，一个页表项对应一个页，所以线性地址的高20位作为页表的索引，每个页表占用4字节，所以这高20位的索引乘以4后才是页表项在相对于页表物理地址的字节偏移量。用cr3寄存器里面的页表物理地址加上此偏移量便是该页表项的物理地址，从该页表项中得到映射后的物理地址。然后用线性地址的低12位与该物理地址相加，所得之和便是最终要访问的物理地址。

![image-20220708072511759](D:/TYPIC/image-20220708072511759.png)





#### 二级页表过程：

一级页表就相当于二级页表里面的页目录中的页目录项所指引的页表的一个BIG版本

###### 二级页表地址转换原理 ：  是将 32 位虚拟地址拆分成高 10 位、中间 10 位、低 12 位三部分，它们 的作用是：高 10 位作为页表的索引，用于在页目录表中定位一个页目录项 PDE，页目录项中有页表物理地址， 也就是定位到了某个页表。中间 10 位作为物理页的索引，用于在页表内定位到某个页表项 PTE，页表项中有分 配的物理页地址，也就是定位到了某个物理页。低 12 位作为页内偏移量用于在已经定位到的物理页内寻址。



`（1）用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的 和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。 （2）用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址， 所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。 （3）最后物理页地址+页内偏移地址就是最终的物理地址了`

![image-20220708075203360](D:/TYPIC/image-20220708075203360.png)





##### 页目录项和页表项存储的4字节结构

![image-20220708075750629](D:/TYPIC/image-20220708075750629.png)

其内容并不全是物理页地址。

*P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。*

*RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。*

*US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页，该页只允许特权级别为 0、1、2 的程序可以访问。*

*PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。这里咱们直接置为 0 就可以啦。*

*PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。这里咱们将其置为 0。*

*A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。还记得段描述符中的 A 位和 P 位吗？这两位在一起可以实现段式虚拟内存管理。和它们一样，这里页目录项和页表项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1。*

*D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项仅针对页表项有效，并不会修改页目录项中的 D 位。*

*PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将此位置 0 即可。*

*G,Global，意为全局位。由于内存地址转换也是颇费周折，先得拆分虚拟地址，然后又要查页目录，又要查页表的，所以为了提高获取物理地址的速度，将虚拟地址与物理地址转换结果存储在 TLB（TranslationLookaside Buffer）中，TLB 以后咱们会细说。在此先知道 TLB 是用来缓存地址转换结果的高速缓存就 ok 啦。*

*此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址啦，无需那三步骤转换。由于 TLB 容量比较小（一般速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。顺便说一句，清空 TLB 有两种方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。*

*AVL，意为 Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位的值。*



#### 启动分页机制前夕

（1）准备好页目录表及页表。 

（2）将页表地址写入控制寄存器 cr3。

 （3）寄存器 cr0 的 PG 位置 1。



页表同描述符表一样，是个内存中的数据结构，处理器要使用它们，必须要知道它们的物理地址，所以页表也有个专门的寄存器来存储其地址。其实这就是前面咱们多次提到的众多控制寄存器（目前处理器中的控制寄存器有 cr0～cr7）中的一个：cr3 寄存器。控制寄存器 cr3 用于存储页表物理地址，所以 cr3 寄存器又称为页目录基址寄存器（Page Directory Base  Register，PDBR）。

![image-20220708081138227](D:/TYPIC/image-20220708081138227.png)

`由于页目录表所在的地址要求在一个自然页内，即页 目录的起始地址是 4KB 的整数倍，低 12 位地址全是 0。所以，只要在 cr3 寄存器的第 31～12 位中写入物理地 址的高 20 位就行了。另外，cr3 寄存器的低 12 位中，除第 3 位的 PWT 位和第 4 位的 PCD 位外，其余位都没 用。PWT 位和 PCD 位在介绍页表项时说过了，它们用于设置高速缓存相关的特性，在此将其置为 0 即可。这样一来低 12 位全部为 0，故只需要把页目录表物理地址的高 20 位写入 cr3 寄存器即可。因为控制寄存器是可以与通用寄存器互相传递数据的，所以为 cr3 寄存器赋值则没有那么复杂，可以用现成的 mov 命令，mov 指令中控制寄存器与通用寄存器互传数据的格式是：mov cr[0～7]，r32 或 mov r32，cr[0～7]。前两部是打开分页机制的铺垫，最后一步是启动cr0的PG位置1，PG位是cro0寄存器的最后一位：31位`









##### 规划页表之操作系统与用户进程的关系

前面讲保护模式时，我们知道，为了计算机安全，用户进程必须运行在低特权级，当用户进程需要访问 硬件相关的资源时，需要向操作系统申请，由操作系统去做，之后将结果返回给用户进程。进程可以有无限 多个，而操作系统只有一个，所以，操作系统必须“共享”给所有用户进程

![image-20220708082707131](D:/TYPIC/image-20220708082707131.png)

​	如何在页表中实现共享呢？这个简单，只要操作系统属于用户进程的虚拟地址空间就好了。为了实现共享操作系统，让所有用 户进程 3GB～4GB 的虚拟地址空间都指向同一个操作系统，也就是所有进程的虚拟地址 3GB～4GB 本质上都是 指向的同一片物理页地址，这片物理页上是操作系统的实体代码。实现起来也比较容易，只要保证所有用户进程 虚拟地址空间 3GB～4GB 对应的页表项中所记录的物理页地址是相同的就行啦。







###### 启动分页机制代码实现

首先，我们要有一个内存布局。

分页机制得有页目录表，页目录表中的是页目录项，其中记录的是页表的物理地址及相关属性，所以还得 有页表。我们实际的页目录表及页表也将按照此空间位置部署，地址的最下面是页目录表，往上依次是页表。页目录表的位置，我们就放在物理地址 0x100000 处。为了让页表和页目录表紧凑一些（这不是必须 的），咱们让页表紧挨着页目录表。页目录本身占 4KB，所以第一个页表的物理地址是 0x101000。

![image-20220708083335910](D:/TYPIC/image-20220708083335910.png)











![image-20220708091518851](D:/TYPIC/image-20220708091518851.png)

创建一个页目录项相当于虚拟空间加了一个页表（仅当新分配的页表映射的物理地址未分配给其他任何页表），一个页表可以表示4MB，所以相当于虚拟空间增加了4MB。

**页目录表每项都是4字节，将相关信息存入首4字节，每个页表指向一块物理地址。**

虚拟地址的算法现在是固定的，在CPU的页部件里面。CPU根据虚拟地址帮你计算是页面项里面的哪个页表，而最后解引用该页表里面的存储的物理地址。所以设计时要将物理地址存在页表，将页表地址存在页目录地址中去，然后将页目录地址存在寄存器CR3中。 然后CPU在算页目录地址和页表地址时是自动关闭页表功能的，其地址代表的就是物理地址。



###### TLB：

一种缓存，不可见，间接更新TLB：重新加载CR3， invlpg m（m为虚拟内存地址）

![image-20220708161111544](D:/TYPIC/image-20220708161111544.png)









**如何利用虚拟地址访问页表地址？**

之前的文章里总结起来就是CPU通过页部件的“三步曲”完成虚拟地址到物理地址的转换关系。

即从CPU的视角是：

        第一步：取虚拟地址的高10位，得到页表首地址；
    
        第二步：取虚拟地址的中10位，得到物理页地址；

第三步：将虚拟地址中的低12位与物理页地址合并，即为最终的物理内存地址。

我们正是利用这种“呆板”机制实现虚拟地址访问页表。即，每一个虚拟地址的转换必须经过这三步。

        比如如何实现利用虚拟地址访问页目录项（页表首地址）？
    
        分析：虚拟地址的结构是不变的，所以我们必须在第二步得到的物理地址还是页目录的首地址。而我们的页目录首地址是存在页目录项的最后位置。所以我说这里是循环访问自己，不知道你能否理解？
    
        答：虚拟地址高10全为1，则CPU在通过页部件转换时，第一步去页目录中定位到最后一项，CPU认为这就是页表首地址了。（但是这里被我们人为安排的地址是页目录自己的）。

CPU傻乎乎的拿着第一步得到的物理地址（页目录首地址），又取了虚拟地址的中间10位，又是全1，则又定位到最后一项。（这里的结果还是页目录首地址。这不就是循环嘛）但是CPU可不这么认为，他觉得经过前两步，我已经成功得到物理页地址了。

CPU说是时候完成地址转换任务了，来人，将第二步结果的物理页地址给我和虚拟地址的低12位合并。随后CPU毕恭毕敬的给老大（也就是作者本人）报告：我已经完成虚拟地址转换了，请您过目。

老大我一看，虚拟地址0xffff_f000 转换成0x10_0000的物理地址。这物理地址就是我页目录首地址啊。甚好甚好。以后我只要给出0xffff_fxxx格式的虚拟地址，CPU就会访问页目录所在的内存区域。

        再进一步，如何利用虚拟地址访问页表项（物理页首地址）呢？
    
        分析：其实CPU通过三步曲就可以得到物理项的地址。这里只希望通过三步曲只得到物理页地址。说明是慢一步。有意为之的慢一步。如何实现呢？
    
        答：多在页目录表里溜达一次。即高10位全给1，则第一步又回到页目录首地址里。原本按照正常计划，第一步就搞到页表地址，第二步搞得物理页地址。现在因为高10位全为1，第一步搞的还是页目录地址，所以第二步只能搞到页表首地址，那么第三步只能在页表里寻址了，得到的自然只能是物理页首地址了。
    
        这时候我们在回到如何访问页目录项（页表首地址）？
    
        其实本质就是慢两步，让第二步结束了得到的地址还是页目录首地址，那么第三步也只能在页目录查询了，得到的也只能是页表首地址了。
