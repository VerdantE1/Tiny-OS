## 完善MBR前序：硬件知识

1.编译器只负责编址，加载器负责装载。编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量。

2.vstart会真实改变加载的数据内存地址，而不改变文本大小（文本中的地址）



CPU执行指令的过程

![image-20220630134135770](D:/TYPIC/image-20220630134135770.png)



# CPU的实模式



CPU中有高速缓存L1,L2,它们都是SRAM，SRAM快的原因是由于其是由寄存器来存储数据的。

**CPU中的寄存器大致分为两类**，一类是内部使用的用全局描述符表寄存器 GDTR、中断描述符表寄存器 IDTR、局部描述符表寄存器 LDTR、 任务寄存器 TR、控制寄存器 CR0～3、指令指针寄存器 IP、标志寄存器 flags、调试寄存器 DR0～7。另外一类是对程序员可见的寄存器，即我们进行汇编语言时能够直接操作的这些寄存器，如段寄存器，通用寄存器。

在实模式下，默认用到的寄存器都是16位宽。

#### 一.实模式下的16位寄存器

具体的寄存器如下：

#### **1.段寄存器**

段寄存器的作用就是指定一片内存的起始地址，故也称为段基址寄存器。尽管段基址在实模 式下要乘以 16，在保护模式下只是个选择子（保护模式中会讲），但其作用就是指定一片内存的起始地址。 而段内偏移地址，顾名思义，仅仅相对于此起始地址的偏移量。CS,DS,SS,ES,FS,GS

![image-20220630140826994](D:/TYPIC/image-20220630140826994.png)

**为什么要段寄存器指向初次访问的内存？**

`举个例子，我想用木材做一个船模，我不可能还用木质工具去加工它，只能用铁器等比木更硬的材料通过削、磨 等方式将它加工出来。换在计算机中也一样，访问内存就要提供地址，初次访问内存时，该地址要么用立即数， 要么存储在某个存储器中能让 CPU 取出来再访问内存，肯定不能用内存本身来存。由于寄存器比内存更高级， CPU 更能接受，所以就用寄存器来存储内存地址。由于要指定的是内存中的一段区域的起始地址，所以称之为 段基址寄存器，也称段寄存器，无论是在实模式下，还是保护模式下，它们都是 16 位宽`



**简要介绍下各段**：

`代码段简而言之就是把所有指令都连续排放在一起，形成了一个全部都是指 令的区域，里面存储的是指令的操作码及寻址方式等。该区域可以在硬盘上的文 件中，也可以是被加载后的内存中，总之是一段指令区域。它们内部都是紧凑挨 着的，内容形式完全一样，只是存放的介质不一样而已。代码段寄存器 CS 就是 用来指向内存中这段指令区域的起始地址。`

` 数据段和代码段类似，只是这段区域中的内容不是指令，而是纯粹的数 据，也就是说里面存储的是程序运行所需要的数据，属于指令的操作数。数据段寄存器 DS 便是用来指向 此数据区域的起始地址。 ` 

`栈段是在内存中，硬盘文件中可真没有。一般的栈段是由操作系统分配指定的，所以是属于被加载到 内存后才有的。本章后面还会讲栈，这里大家就先当它是一段内存区域就好。栈段寄存器 SS 就是用来指 向此区域的起始地址。 `

`附加段寄存器？其实就是多给 大家提供几个段寄存器用而已，多几个寄存器用不是更好吗，省得紧巴巴的，纯粹是为了方便大家。 值得说明的是在 16 位 CPU 中，只有一个附加段寄存器—ES。而 FS 和 GS 附加段寄存器是在 32 位 CPU 中增加的。我们使用的是 32 位 CPU，并不是说 32 位 CPU 在实模式下的 16 位环境中就不能用 FS 和 GS 寄存器。32 位的 CPU 兼容 16 位 CPU 的特性，就像一个小学生也可以穿中学生的衣服一样，无非是 多了个可用的资源。`



#### **2.FLAG寄存器和IP寄存器**

`flags 寄存器是计算机的窗口，为不可见寄存器，展示了 CPU 内部各项设置、指标。任何一个指令的执行、其执行过程的细节、 对计算机造成了哪些影响，都在 flags 寄存器中通过一些标志位反映出来。有些指令需要满足某些条件才能执行， 它们的条件是判断上一条指令的执行过程。所以标志寄存器中的标志位就成了这些指令所需要满足的条件。实模 式下的 flags 寄存器是 16 位的，如图 3-5 所示。后面专门拿出一节讲 flags 寄存器，这里先一带而过。`



`IP 寄存器是不可见寄存器，CS 寄存器是可见寄存器。这两个配合在一起后就是 CPU 的罗盘，它们是 ▲图 3-3 实模式下的段寄存器 异步社区会员 databus(17602509427) 专享 尊重版权 3.2 CPU 的实模式 75 给 CPU 导航用的。CPU 执行到何处，完成要听这两个寄存器的安排。为什么要用两个寄存器？因为指令 是在内存中，访问内存就要用“段：段内偏移”的形式，所以 CS 寄存器用来存代码段段基址，IP 寄存器 用来存储代码段段内偏移地址，同 CS 寄存器一样都是 16 位宽`

![image-20220630142125858](D:/TYPIC/image-20220630142125858.png)



#### 3.通用寄存器

分别是 AX、BX、CX、 DX、SI、DI、BP、SP

`拿 AX 寄存器举例，根据图 3-6 可知，AX 寄存器是由 AH 寄存器和 AL 寄存器组成的，它们都是 8 位寄存器，AX 寄存器的低 8 位，即 0～7 位，是 AL 寄存器。高 8 位，即 8～15 位，是 AH 寄存器。由于某种原因（如数学 计算和 32 位保护模式等），16 位 AX 寄存器不够用了，将其扩展（Extend） 为 32 位，在 AX 原有的基础上，增加 16 位作为高 16 位便是扩展的 AX，即 EAX。所以 EAX 归根结底也是由 AL、AH 组成的，AL 或 AH 值变了直接 影响 EAX。这里提及了寄存器 eax 的原因是在实模式下虽然操作数是 16 位， 但依然可以用 32 位寄存器，因为我们所讲的是 32 位 CPU 在实模式下的工作状态，并不是纯粹的 16 位 CPU， 如 8086。 `

`以上的这 8 个寄存器实际上是通用寄存器，通用是说每个寄存器的功能不单一，可以有多种用途，不 像段寄存器 SS 那样只能用来放栈段基址，通用寄存器可以用来保存任何数据，包括地址（当然，地址也 是一串数字，还是数据）`

**虽说通用，但还是约定了它们的惯用法，除了通用的用途外每个寄存器肩负特定的功用**。比如 一般情况下，cx 寄存器用作循环的次数控制，bx 寄存器用于存储起始地址。这是大家约定俗成的东 西，不这样做也可以，用其他通用寄存器也能完成任务。不过还是有个公共的约定更好，这样一些 通用的函数，在为其传递参数时会方便很多。比如 BIOS 或 DOS 中断调用，一般情况下，cx 还就是 用作循环次数的控制，有了这样公共的认知，函数在使用上会方便，且显得轻松很多。另外，一些 指令已经固定用一些特定的寄存器作为参数了，比如 esi 寄存器作为很多有关数据复制指令的源地 址，edi 作为目的地址。

简短介绍下各通用寄存器特定的功能

[^regs sepical func]:below is the special functions of each reg

![image-20220630142737851](D:/TYPIC/image-20220630142737851.png)



#### 二.实模式下的寻址方式

大方向来分为三类：1.寄存器寻址，2.立即数寻址，3.内存寻址

在第三种内存寻址中又分为 1.直接寻址 2.基址寻址 3.变址寻址 4.基址变址寻址



**寄存器寻址**

最直接的寻址方式就是寄存器寻址，它是指“数”在寄存器中，直接从寄存器中拿数据就行了。例如 下面用 mul 指令实现 0x10*0x9

```asm
mov ax, 0x10 
mov dx, 0x9 
mul dx
```

`以上三条指令都是寄存器寻址。 第一条命令是将 0x10 存入 ax 寄存器，第二条命令是将 0x9 存入 dx，第三条指令是求 ax 和 dx 的乘积， 乘积的高 16 位在 dx 寄存器，低 16 位在 ax 寄存器。只要牵扯到寄存器的操作，无论其是源操作数，还是目 的操作数，都是寄存器寻址。上面的第一、二条指令，它们的源操作数都是立即数，所以也属于立即数寻址。`



**立即数寻址**

`什么是立即数？立即数就是常数。常数就常数呗，为什么拐着弯叫别的名呢？ 是这样的，指令由操作码和操作数组成，得到一个数往往不容易，或者说不那么直接。这个数要么在 寄存器中，要么在内存中，都是间接给出的，所以得到数就要花费一些 CPU 周期。如果操作数“直接” 存在指令中，直接拿过来，立即就能用了。为了突显“立即就能用”的高效率，此数便称为立即数。立即 数免去了找数的过程，CPU 最喜欢它啦`

```asm
mov ax,0x18 
mov ds, ax 	
```

`第一条指令中的源操作数 0x18 是立即数，目的操作数 ax 是寄存器，所以它既是立即数寻址，也是寄 存器寻址。第二条指令中，源操作数和目的操作数都是寄存器，所以纯粹是寄存器寻址。 提醒一下，像这样的寻址也是立即数寻址.在编译阶段会转换为数字，最终可执行文件中的依然是立即数`

```asm
mov ax, macro_selector 
mov ax, label_start 	
```

**内存寻址**

`以上两种寻址方式，操作数一个是在寄存器中，一个是在指令中直接给出。它们都不在内存中。操作 数在内存中的寻址方式称为内存寻址。CPU 中有很多寄存器，有些是程序员不可见的，它们是为了 CPU 正常运行而存在的，属于 CPU 运行框架
内的需求。CPU 给程序员用的寄存器并不是很多，所以操作数一多起来的时候，基本就倒腾不开了。内存空间相对就大多了，于是 CPU 工程师们自然而然想到了用内存来存储操作数。另外，用立即数寻址，得提前知道立即数是多少，否则还真用不了。而且，大多数时候操作数位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值，更谈不上将其变成立即数用在指令中了，这就更加有理由让内存寻址成为“应该”。`

`由于访问内存是用“段基址：偏内偏移地址”的形式，特别强调一下，此形式只用在内存访问中。默认情况下数据段寄存器是 DS，即段基址已经有了，只要再给出段内偏移地址就可以访问内存了，最终起决定作用的、有效的是段内偏移地址，所以段内偏移地址称为有效地址`

```asm
mov ax, [0x1234]      默认DS段
mov ax, [fs:0x5678]   

~直接寻址


mov word[bx],0x1234

~基址寻址  bx的默认段寄存器为DS,bp是默认段寄存器为SS。
基址寻址，就是在操作数中用 bx 寄存器或寄存器作为地址的起始，地址的变化以它为基础。在实模式下就是这样的，必须用 bx或 bp 寄存器。到了保护模式下就没这个限制了，基址寄存器可选择的很多，可以是全部的通用寄存器。  用于在段中当指针维护段。 p92绿字



mov [di],ax
mov [si+0x1234],ax

~变址寻址，和基址寻址类似，只是寄存器换成了si,di。两个寄存器的默认寄存器也是ds.变址寻址主要是用于字符搬运方面的指令，这两个寄存器在很多指令中都要成对使用，如 movsb，movsw，movsd 等，我们的代码中也用到了此命令，讲到时会细说，目前大家有兴趣可自行查阅。其实单纯的变址寻址没什么新鲜的，它只是为了配合基址寻址，用来实现基址变址寻址。



mov [bx+di], ax 
add [bx+si], ax 

~基址变址寻址

第一条指令是将 ax 中的值送入以 ds 为段基址，bx+di 为偏移地址的内存。第二条指令是将 ax 与[ds：bx+si]处的值相加后存入内存[ds：bx+si]。


最后说明一下：

在咱们项目里的汇编代码里还没有这么用的，不做过多演示，大家知道有这种形式就行。CPU 访问数据的方式看上去很死板（有些寄存器是规定的），原因是一种寻址方式对应一种电路实现，增加一种寻址方式，会增加硬件电路的复杂性，所以寻址方式是有限的。就拿“mov ax，[bx+si]”来说，您有没有疑问，换成 mov ax，[cx+dx]行不行？这在逻辑上没有任何问题，我不觉得它们之间有什么不同，咱们关心的是 bx+si 要等于 cx+dx 就行了。这是人类的理解，我们不知不觉中站在了抽象层来看待这个偏移地址，即咱们关注的是这个数是否正确，而不管这个数是怎么来的。对于有效地址（段内偏移地址），不管其形式是寄存器、立即数，还是内存中的值，甚至是个表达
式，它在人类眼里只是个数字，按理来说都是一样的，不应该强调具体形式。可是这对计算机硬件实现来说却是截然不同的，所以才又细分了这么多的寻址形式。给大家举个生活中的例子
大家吃饭时对于主食的选择，有人喜欢吃饼，有人喜欢吃米饭。虽然它们都是主食，但这两种食物的加工方法必须是不同的，饼是用饼铛做出来的，米饭是用锅蒸出来的。想吃饼类食物，其制作过程就一定要用到饼铛，这是最底层不变的东西。无论做出的是鸡蛋饼，还是馅饼，其上层形式无论多丰富，万变不离其宗，都是经过饼铛烹制而成的。
CPU 的寻址方式看似不灵活，有的甚至要背下来，这是因为这和人类理解的方式是不一样的，人类是站在抽象层来看待寻址的，如果站在底层来看它们，就会理解在这么多的寻址方法中，为什么看似一样却又有这么多形式，就是因为 8086在寻址方面的硬件电路做得简单有限，为了更简单，某些功能中使用的寄存器甚至要“写死”。如该用基址寻址时，电路中就只针对 bx 或 bp 寄存器，从硬件上就没考虑其他寄存器。

```



[^基址寻址reg]:如bp的作用，进入函数时创建维护空间，退出函数时回收局部变量空间

![image-20220630151354007](D:/TYPIC/image-20220630151354007.png)

# CPU与外设通信的方式：IO接口



硬件很多，且种类很多，CPU很忙，不可能全部由其一人来管理，就像校长面临一群学生一样，让校长亲自管理每个学生的学习，即使是肌肉男施 瓦辛格也得累倒，于是，班主任的出现帮了大忙，每个班主任负责一批学生，由他们了解学生的情况后再 向校长汇报，这样校长他不需要过人的体格，工作起来也会游刃有余了。于是充当班主任的角色的就是**IO接口**，**IO接口管理硬件与CPU的通信**

任何不兼容的问题，都可以通过增加一“层”来解决。

**IO 接口是连接 CPU 与外部设备的逻辑控制部件，既然称为逻辑，就说明可分为硬件和软件两部分。**

`硬件部分所做的都是一些实质具体的工作，其功能是协调 CPU 和外设之间的种种不匹配，如双方由于速 度不匹配，那 IO 接口就实现数据缓冲以减少等待时间，数据格式不匹配，IO 接口就在这两种格式间互相 转换。IO 接口内部实际上也是由软件来控制运作的，这就是所谓的“逻辑”部分，所以软件是指用来控 制接口电路工作的驱动程序以及完成内部数据传输所需要的程序。`

既然提到了软件，这就意味着编程，这样一来，IO 接口芯片又可按照是否可编程来分类，可分为可 编程接口芯片和不可编程接口芯片。计算机和IO接口的通信是通过计算机指令来实现的，我们通过软件指令选择IO接口上的功能，工作模式的作法称为 **IO接口控制编程** 通常用到in/out来实现的。

CPU 太忙了，它的时间特别宝贵，为了简化 CPU 访问外部设备的工作，能够轻松地同任何硬件通信， 大家就约定好 IO 接口的功能。

`1．设置数据缓冲，解决 CPU 与外设的速度不匹配`

`2．设置信号电平转换电路`

`3．设置数据格式转换`

`4．设置时序控制电路来同步 CPU 和外部设备`

`5．提供地址译码`



同一时刻，CPU 只能和一个 IO 接口通信，当很多的 IO 接口 同时想和 CPU 对话时，面对众多接口的爱慕，CPU 会选择和谁 单独一叙呢？ 这一层的责任是除了仲裁 IO 接口的竞争，还要连接各 种内部总线。由于它的使命，它的名字就叫做**输入输出控制中心** （I/O control hub，ICH），也就是南桥芯片。**控制各类IO接口和CPU通信**。 控制包括选择，维护。

在南桥内部集成了一些 IO 接口，如并口硬盘 PATA（就是我们平时所说的 IDE 硬盘）、串口硬盘 SATA、USB、 PCI 设备、电源管理等接口。由于这些接口对微型计算机来说必不可少，它们就直接扎根在南桥内部啦。南桥芯片即相当于一个**公共线路。**



![image-20220701121617670](D:/TYPIC/image-20220701121617670.png)

IO 接口在诞生之初，就被设计成要通过寄存器的方式同 CPU 通信，其内部有专用于数据交互的寄存器，只不过这里所说的这些寄存 器位于 IO 接口中，为了区别于 CPU 内部的寄存器，IO 接口中的寄存 器就称为端口（这可不是网络应用程序所开的那种端口，如网络服务 器会启动 80 端口，这是两码事）。**即端口（寄存器）是IO接口和CPU数据交互的寄存器。那么CPU如何访问端口呢？**要是通过内存映射，端口就可以用 mov 指令来操作。但由于用的是独立编址，所以就不能把它当作 内存来操作，因此 CPU 提供了专门的指令来干这事，in 和 out.

```asm
in 指令用于从端口中读取数据，其一般形式是：
（1）in al, dx；
（2）in ax, dx。
其中 al 和 ax 用来存储从端口获取的数据，dx 是指端口号。
这是固定用法，只要用 in 指令，源操作数（端口号）必须是 dx，而目的操作数是用 al，还是 ax，取
决于 dx 端口指代的寄存器是 8 位宽度，还是 16 位宽度。
out 指令用于往端口中写数据，其一般形式是：
（1）out dx, al；
（2）out dx,ax；
（3）out 立即数, al；
（4）out 立即数, ax。
注意啦，这和 in 指令相反，in 指令的源操作数是端口号，而 out 指令中的目的操作数是端口号
```



# 显卡

`显卡是 pci 设备，所以是安装在主板上 pci 插槽上的，pci 总线是共享并行架构，并行数据就要保证数 据发送后必须同时到达目的地，因为这关系到数据的顺序，不能发过去后成一团乱麻。例如 8 位并行总线 就需要同时发送这 8 位，接收方也要同时接收这 8 位才行。虽然貌似并行传输是高效的，但对于要保证同 时接收 n 位数据，这是有困难的，随着并行数据的位宽越来越大，这种困难也越来越明显。于是串行传输 很好地解决了这一问题，一次只发一位，这样顺序问题解决了，数据到目的地看再组合到一起就成了。于 是就有了 PCI Express 总线，这就是串行设备，简称 pcie`

某些IO接口也叫适配器，适配器是**驱动**某一外部设备的功能模块。显卡也叫显示适配器（或显示器IO接口？），它是用于CPU和显示器之间的数据通信的IO接口。

我们的输出都是通过直接操作显卡来实现的，而IO接口显卡给我们的输入接口是显存和端口，我们主要用的是显存。显存作为接口，说白了，就是它把显存直接给我们用，说：“把你要输出的内容写到这 里面，我照着往屏幕上打印”。

显卡支持三种模式，文本模式、黑白图形模式、彩色图形 模式。由于要在显示器上显示文本需要一点点的像素进行描绘，这是对于程序员来说很麻烦，所以规定了一种编码模式，一些特定的编码对应一种描绘方式，于是有了ASCII码，一种码对应一种字符，对应一种描绘方式。然后，每个字符在屏幕上都 是由 2 个字节来表示的，而且是连续的 2 个字节。

一种简短的字符与属性描述

![image-20220701154631135](D:/TYPIC/image-20220701154631135.png)



显卡内存分布

![image-20220701155317065](D:/TYPIC/image-20220701155317065.png)

# 硬盘

`硬盘控制器同硬盘的关系，如同显卡和显示器一样，它们都是专门驱动外部设备的模块电路，CPU 只同 它们说话，由它们将 CPU 的话转译给外部设备。这是它们的共同点，但不同的是显卡和显示器是分开的，硬 盘控制器和硬盘是连接在一起的，至少在我接触计算机以来一直就是这样的，从未变过，也不曾怀疑过。但我 有天被告知，在很久很久以前，硬盘控制器和硬盘也是分开的，就像显卡和显示器一样。显示器太大了，怎么 能装在机箱里呢，当然要和显卡分开了。可硬盘控制器和硬盘都那么小，为什么还要分开呢？是啊，为什么呢，我也不知道，可它们在很久以前就是分开的。后来业界的几个老大合作开发出一种 新的接口，这样才将硬盘和硬盘控制器整合在一起，为了突显“整合”之意，硬盘控制器和硬盘终于在一 起了，这种接口便称为集成设备电路（Integrated Drive Electronics，IDE）。`

前几年刚出道的硬盘串行接口（Serial ATA，SATA），由于其是串行，所 以之前的 ATA 接口只好称为并行 ATA，即（Parallel ATA，PATA）。

![image-20220702123846925](D:/TYPIC/image-20220702123846925.png)

这两种线缆完全不同，左边 PATA 接口的线缆也称为 IDE 线，一个 IDE 线上可以挂两块硬盘，一个 是主盘（Master），一个是从盘（Slave）。不过按 ATA 的 说法，这两个插槽称为通道，IDE0 叫作 Primary 通道，IDE1 叫作 Secondary 通道。



让硬盘工作，我们需要通过读写硬盘控制器的端口，端口的概念在此重复一下，端口就是位于 IO 控 制器上的寄存器，此处的端口是指硬盘控制器上的寄存器

![image-20220702124032665](D:/TYPIC/image-20220702124032665.png)



端口可以被分为两组，Command Block registers 和 Control Block registers。Command Block registers 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作 状态。

**端口是按照通道给出的，也就是说，大家不要像我当初那样误以为端口是直接针对某块硬盘的，不是 这样的，一个通道上的主、从两块硬盘都用这些端口号。**



data寄存器：data 寄存器在名字上我们就知道它是负责管理数据的，它相当于数据的门，数据能进，也能出，所以其 作用是读取或写入数据。在读硬盘时，硬盘准备好的数据后，硬盘控制器将其放在内部的缓冲 区中，不断读此寄存器便是读出缓冲区中的全部数据。在写硬盘时，我们要把数据源源不断地输送到此端口， 数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。



error寄存器：读硬盘时，端口 0x171 或 0x1F1 的寄存器名字叫 Error 寄存器，只在读取硬盘失败时有用，里面才会 记录失败的信息，尚未读取的扇区数在 Sector count 寄存器中。在写硬盘时，此寄存器有了别的用途，所 以有了新的名字，叫 Feature 寄存器。有些命令需要指定额外参数，这些参数就写在 Fea ture 寄存器中。 强调一下，error 和 feature 这两个名字指的是同一个寄存器，只是因为不同环境下有不同的用途，为了区 别这两种用途，所以在相应环境下有不同的名字。这两个寄存器都是 8 位宽度。



Sector count寄存器：Sector count 寄存器用来指定待读取或待写入的扇区数。硬盘每完成一个扇区，就会将此寄存器的值 减 1，所以如果中间失败了，此寄存器中的值便是尚未完成的扇区。这是 8 位寄存器，最大值为 255，若 指定为 0，则表示要操作 256 个扇区。



Staus寄存器：在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的 状态信息。在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，和上面说过的 error 和 feature 寄存器情况 一样，只是用途变了，所以换了个名字表示新的用途，它和 status 寄存器是同一个。此寄存器用来存储让硬 盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。

在咱们的系统中，主要使用了三个命令。

`（1）identify：0xEC，即硬盘识别。`

`（2）read sector：0x20，即读扇区`

`（3）write sector：0x30，即写扇区。`

总结下寄存器 error、feature 和 status、command，大家可以这样来助记：**这两组都是同一寄存器（也 就是同一端口）多个用途，对同一端口写操作时，硬盘控制器认为这是个命令，对同一端口读操作时，硬盘控制器认为是想获得状态**

![image-20220702124515108](D:/TYPIC/image-20220702124515108.png)







实践约定：

最主要的顺序就是 command 寄 存器一定得是最后写，因为一旦 command 寄存器被写入后，硬盘就开始干活啦，它才不管其他寄存器中 的值对不对，一律拿来就用，有问题的话报错就好啦。其他寄存器顺序不是很重要。

那咱们可以约定个操作顺序，免得大家感到无所适从，请原谅我这么说，因为我就有选择恐惧症，我 很理解像我这样的同学。咱们还是约定个步骤好

`（1）先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。 （2）往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。 （3）往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。 （4）往该通道上的 command 寄存器写入操作命令。 （5）读取该通道上的 status 寄存器，判断硬盘工作是否完成。 （6）如果以上步骤是读硬盘，进入下一个步骤。否则，完工。 （7）将硬盘数据读出`

硬盘工作完成后，它已经准备好了数据，咱们该怎么获取呢？一般常用的数据传送方式如下。

（1）无条件传送方式。 （2）查询传送方式。 （3）中断传送方式。 （4）直接存储器存取方式（DMA）。 （5）I/O 处理机传送方式。

硬盘不符合第 1 种方法，因为它需要在某种条件下才能传输。第 4 种和第 5 种需要单独 的硬件支持，先不说我们的 bochs 能否模拟这两种硬件，单独学习这两类硬件的操作方法就很头疼，大 家有兴趣的话还是先放一放，以后再琢磨吧。所以在我们的系统中，我们用了第 2、3 这两种软件传输 方式。



# 开始实践！out

