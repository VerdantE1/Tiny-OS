##  	14：中断执行流程

#### 简介

![image-20220722154318173](D:/TYPIC/image-20220722154318173.png)

中断描述符表中的描述符有自己的名称——门，不是选择子。门表示一段程序的入口，它和段描述符相比，段描述符描述的是一个相应的内存空间，门描述符描述的是一段代码。



门分为四种：任务门，中断门，陷阱门，调用门。

介绍下中断门

![image-20220722154826546](D:/TYPIC/image-20220722154826546.png)



中断门包含了中断处理程序所在段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存器eflags中的IF位自动设置为0，也就是进入中断后，自动把中断关闭，避免中断嵌套，Linux中断门实现的系统调用即那个著名的int 0x80即是用此。



**现代操作系统为了简化开发、提升性能和移植性等原因，很少用到调用门和任务门。所以本书中对它 们的讨论也少之又少，我们会把精力放在中断门，像 Linux 那样，用它来实现系统调用。**













#### IDT和IVT的区别



还记得很久很久以前说过的低端 1MB 内存布局吗？位于地址 0～0x3ff 的是中断向量表 IVT，它是实 模式下用于存储中断处理程序入口的表。由于实模式下功能有限，运行机制比较“死板”，所以它的位置 是固定的，必须位于最低端。大家看到了，已知 0～0x3ff 共 1024 个字节，又知 IVT 可容纳 256 个中断向 量，所以每个中断向量用 4 字节描述。

**对比保护模式下的中断描述符表和实模式下的中断向量表**

1.**中断描述符表地址不限制，在哪里都可以**

2.**中断描述符表中的每个描述符用8字节描述**

既然IDT位置不固定，那么中断发生，CPU如何找到它呢？答案就如GDT一样，用一个寄存器存储IDT基址，该寄存器即为IDTR。

![image-20220722155414975](D:/TYPIC/image-20220722155414975.png)

16位表界限，说明最大的范围是0xffff即64KB，可容纳描述符个数是64KB/8=8192个。注意的是GDT中的第0个段描述符是不可用的，但是IDT却无此限制，第0个门描述符是可用的，中断向量号为0的中断是除法错。

在门描述符中有个P位，所以，咱们将来在构建IDT时，记得把P位置0，这样就表示门描述符中的中断处理程序不在内存中。同加载GDTR一样，加载IDTR也有个专门的指令——lidt。用法如GDTR一样。	

​										              		**lidt     48位内存数据**

















#### 中断处理过程



了解中断描述符表之后，咱们说一下从中断发生到中断处理的过程，过程中涉及到特权级检查，也就是本节所说的保护。完整的中断过程分为CPU外和CPU内两部分

完整的中断过程分为CPU外和CPU内两部分

CPU外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU

CPU内：CPU执行该中断向量号对应的中断处理程序

完整过程：

（1）处理器根据中断向量号定位中断门描述符

（2）处理器进行特权级检查

```shell
由于中断是通过中断向量号通知到处理器的，中断向量号只是个整数，其中并没有 RPL，所以在对由中断引起的特权级转移做特权级检查中，并不涉及到 RPL。中断门的特权检查同调用门类似，对于软件主动发起的软中断，当前特权级 CPL 必须在门描述符 DPL 和门中目标代码段 DPL 之间。这是为了防止位于3特权级下的用户程序主动调用某些只为内核服务的例程。
```

​						`（a）如果是由软中断 int n、int3 和 into 引发的中断，这些是用户进程中主动发起的中断，由用户代码 控制，处理器要检查当前特权级 CPL 和门描述符 DPL，这是检查进门的特权下限，如果 CPL 权限大于等 于 DPL，即数值上 CPL≤门描述符 DPL，特权级“门槛”检查通过，进入下一步的“门框”检查。否则， 处理器抛出异常。 `

​						`（b）这一步检查特权级的上限（门框）：处理器要检查当前特权级 CPL 和门描述符中所记录的选择子 对应的目标代码段 DPL，如果 CPL 权限小于目标代码段 DPL，即数值上 CPL>目标代码段 DPL，检查通 过。否则 CPL 若大于等于目标代码段 DPL，处理器将引发异常，也就是说，除了用返回指令从高特权级 返回，特权转移只能发生在由低向高`



##### CPL



　　**CPL是当前执行的程序或任务的特权级。它被存储在CS和SS的第0位和第1位上**。通常情况下，CPL代表代码所在的段的特权级。**当程序转移到不同特权级的代码段时，处理器将改变CPL。只有0和3两个值，分别表示用户态和内核态。** CS,SS代表了指令的控制寄存器











(3) 执行中断处理程序



中断发生后，eflags中的NT位和TF位会被置为0.如果中断对应的门描述符是中断门（说明中断不一定都是由中断门引起的），标志位IF位被自动置为0，避免中断嵌套。

若中断发生时对应的描述符是任务门或陷阱门的话， CPU 是不会将 IF 位清 0 的。因为陷阱门主要用 于调试，它允许 CPU 响应更高级别的中断，所以允许中断嵌套。而对任务门来说，这是执行一个新任务， 任务都应该在开中断的情况下进行，否则就独占 CPU 资源，操作系统也会由多任务退化成单任务了。



（4）从中断返回

从中断返回的指令是iret,它从栈中弹出数据到寄存器cs,eip,eflags等，根据特权级是否改变，判断是否要恢复旧栈，也就是说是否将栈中位于SS_old和ESP_old位置的值弹出到寄存器ss和esp,当中断处理程序执行完成返回后，通过iret指令从栈中恢复eflags的内容。

**当然如果大伙儿愿意的话，可以在中断处理程序中将 IF 位打开，这样便可以根据需要优先处理更高 特权级的中断。可是如何打开此位呢**？

用pushf可以，但是有内存参与是低效率，并且此操作是由多个步骤完成，执行过程容易被拆开，不能保证操作的原子性，所以处理其提供了专门用于控制IF位的指令，通过它，IF 可以直接控制。**指令 cli 使 IF 位为 0，这称为关中断，指令 sti 使 IF 位为 1，这称为开中断。**



IF 位只能限制外部设备的中断，对那些影响系统正常运行的中断都无效，如异常 exception，软中断， 如 int n 等，不可屏蔽中断 NMI 都不受 IF 限制。



















#### **为什么进入中断时要把NT位和TF位置为0？**



TF表示trap flag,陷阱标志位，这用在调试环境中，当TF为0时表示禁止单步执行，	也就是说进入中断后将TF置为0，表示不允许中断程序单步执行。

NF为nest task flag,任务嵌套标志位，任务嵌套调用是指 CPU 将当前正执行的旧任务挂起，转去执行另外的新任务，待新任务执行完后，CPU 再回到旧任务继续执行。

为什么 CPU 执行完新任务后还能回到旧任务呢？原因是在执行新任务之前，CPU 做了两件准备工作。

（1）将旧任务 TSS 选择子写到了新任务 TSS 中的“上一个任务 TSS 的指针”字段中。

 **（2）将新任务标志寄存器 eflags 中的 NT 位置 1，表示新任务之所以能够执行，是因为有别的任务调 用了它**

CPU 把新任务执行完后还是要回去继续执行旧任务的，怎样回到旧任务呢？这也是通过 iret 指令。iret 指令 因此有了两个功能，一是从中断返回，另外一个就是返回到调用自己执行的那个旧任务，这也相当于执行一个任 务。**那么问题来了，对同一条 iret 指令，CPU 是如何知道该从中断返回呢，还是返回到旧任务继续执行呢？** 这就用到 NT 位了，当 CPU 执行 iret 时，它会去检查 NT 位的值，如果 NT 位为 1，这说明当前任务 是被嵌套执行的，因此会从自己 TSS 中“上一个任务 TSS 的指针”字段中获取旧任务，然后去执行该任 务。如果 NT 位的值为 0，这表示当前是在中断处理环境下，于是就执行正常的中断退出流程。



















#### 中断发生时的压栈





























