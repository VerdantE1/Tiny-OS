## 9：进入保护模式前的获取内存

保护模式最“大”的特点就是寻址空间“大”，在进入保护模式之后，我们将接触到虚拟内存，内存管理等。但这些和内存有关的概念都建立在物理内存之上，无论理论概念说得多高大上，最终也要在物理内存上落实行动。为了在后期做好内存管理工作，咱们先得知道自己有多少物理内存

##### 思路：在实模式下，调用BIOS的中断0x15例程获取内存

如linux 2.6内核中，是用detect_memory函数来获取内存容量的。其函数在本质上是通过调用BIOS中断0x15实现的，分别是BIOS中断0x15的3个子功能，子功能号要放在寄存器eax或ax中。如下：

```cpp
EAX=0xE820：遍历主机上全部内存。
AX=0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。
AH=0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。
```

BIOS 中断是实模式下的方法，只能在进入保护模式前调用。咱们效仿 Linux“不弃不舍”的精神， 在实模式下也用这三种方法检测完内存容量后再进入保护模式。







三个API的用法

###### 1.0x15子功能0xe820

`BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局，由于系统内存各部分的类型属性不同， BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存 信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属 性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存 储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS）`

![image-20220707162305216](D:/TYPIC/image-20220707162305216.png)

`其中的 Type 字段用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，即其是可以被 操作系统使用，还是保留起来不能用。`

![image-20220707162354941](D:/TYPIC/image-20220707162354941.png)





调用规则：

![image-20220707164054873](D:/TYPIC/image-20220707164054873.png)





###### 2.0XE801

顶多记录0~4GB之内



调用规则：

![image-20220707164223922](D:/TYPIC/image-20220707164223922.png)

`低于 15MB 的内存以 1KB 为单位大小来记录， 单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的实际内存容量 =AX*1024。AX、CX 最大值为 0x3c00，即 0x3c00*1024=15MB。16MB～4GB 是以 64KB 为单位大小来记录的， 单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的，所以 16MB 以上空间的内存实际大小 =BX*64*1024，不用在意 BX 和 DX 最大值是多少，前面说过啦，只支持 4GB 空间`





###### 3.0X88

`最后一个获取内存的方法也同样是 BIOS 0x15 中断，子功能号是 0x88。该方法使用最简单，但功能 也最简单，简单到只能识别最大 64MB 的内存。即使内存容量大于 64MB，也只会显示 63MB，大家可以 自己在bochs中试验下。为什么只显示到63MB呢？因为此中断只会显示1MB之上的内存，不包括这1MB`

![image-20220707164407961](D:/TYPIC/image-20220707164407961.png)





代码

loader.bin加载地址是0x900,

```asm
```



