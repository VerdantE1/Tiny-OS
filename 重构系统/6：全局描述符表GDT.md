# 全局描述符表GDT

为了安全策略，CPU提供了保护模式，到了保护模式下，内存寻址方式依然是**段基址+段内偏移地址**，但是CPU为了增加安全性，即维护了内存的访问属性等，即构建了全局描述符表GDT，此后的段寄存器不再是简简单单的存储段基址了，而存储的是一个选择子。

**GDT相当于保护模式下内存段的登记表，其表项即 段描述符相当于内存段的一个身份证。**

GDT的表项：段描述符格式如图

![image-20220705133107531](D:/TYPIC/image-20220705133107531.png)

段界限表示段边界的扩展最值，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。对于数据段和代码段扩展方向是向上即地址越来越高，此时段界限用来表示段内偏移的最大值。对于栈段是向下扩展。段界限的作用如同其名，表示段的边界，大小，范围。段界限用20个二进制位来表示，只不过此段界限是个单位量，其段位要么是字节，要么是4KB这是由描述符的G位制定的。**故段最终边界是此段界限值*段位**，所以可以算出段范围是（1MB~4GB）。

CPU眼里凡是硬件运行需要的东西都称之为系统，凡是软件（操作系统也属于软件,CPU眼中，它与用户程序并无区别）需要的东西都称为数据。

一个段描述符，在 CPU 眼里分为两大类，要么描述的是系统段，要么描述的是数据段。

###### 什么是系统段？各种称为“门”的结构便是系统段，也是硬件系统需要的结构，非软件使用，如调用门，任务门。简而言之，门的意思就是入口，它通往一段程序



8~11位为type字段，共4位用来指定本描述符的类型。type字段是和S字段配和在一起才能确定段描述符的确切类型，只有S确定后，type字段的值才有意义。

12位为S段，决定指示是否是系统段。S为0表示系统段，S为1表示数据段。

![image-20220705135029190](D:/TYPIC/image-20220705135029190.png)

13~14位是DPL字段，Descriptor Privilege Level，即描述符特权级，这是保护模式提供的安全解决方案。描述的是该段描述符所指向的内存段的特权级。两位能表示4种特权级，分别是0，1，2，3。CPU由实模式进入保护模式后，特权级自动为0，用户程序的特权级通常为3。数字越小特权级越大。

15位是P字段，Present，即段是否存在于内存中。通常情况下，段是在内存中，当内存不足时置换段，该功能就有用



20位AVL，AVaiLable，可用不可用是对用户来说的，也就是操作系统可以随意用此位。对硬件来说无用途

21位L，用来设置是否是64位代码段。L为1表示64位代码段，否则表示32位代码段。

22位是D/B字段，用来指示有效地址（段内偏移地址）以及操作数大小。也就是用于识别指令的位数类型

`对于代码段来说，此位是 D 位，若 D 为 0，表示指令中的有效地址和操作数是 16 位，指令有效地址 用 IP 寄存器。若 D 为 1，表示指令中的有效地址及操作数是 32 位，指令有效地址用 EIP 寄存器。 对于栈段来说，此位是 B 位，用来指定操作数大小，此操作数涉及到栈指针寄存器的选择及栈的地 址上限。若 B 为 0，使用的是 sp 寄存器，也就是栈的起始地址是 16 位寄存器的最大寻址范围，0xFFFF。 若 B 为 1，使用的是 esp 寄存器，也就是栈的起始地址是 32 位寄存器的最大寻址范围，0xFFFFFFFF。`

23位是G字段，段界限单位大小。









###### GDT Registers

称其为“全局”描述符表，全局体现在多个程序都可以在里面定义自己的段描述符，是公用的。GDT位于内存中，需要专门的寄存器GDT Register指向它，专门用来存储它的内存地址以及大小。GDTR是个48位的寄存器，如图所示

![image-20220705140400055](D:/TYPIC/image-20220705140400055.png)

不过对于此寄存器的访问，不能用mov gdtr,xxx来为其初始化。有专门的指令来做这件事，这就是lgdt指令。虽然我们是为了进入保护模式才讲述的lgdt，因此看上去此指令是在实模式下执行的，但实际上，此指令在保护模式下也能够执行。言外之意便是进入保护模式需要有GDT，但进入保护模式后，还可以再重新换个GDT加载。在保护模式下重新换个GDT的原因是在实模式下只能访问到最大为2的20次方即1MB的内存，根据操作系统的实际情况，可能需要将GDT放在其他内存位置，所以保护模式也可以用lgdt.

GDTR这48位内存数据划分为两部分，其中前16位是GDT以字节为单位的界限值，后面是GDT的内存起始值。

GDT中最多有8192个描述符。









**选择子**

段描述符有了，描述符表也有了，我们该如何使用它呢？下面我们引出新概念：段的选择子。段寄存器CS,DS,ES,FS,GS,SS在实模式下，段中存储的是段基地址，即内存段的起始地址。而在保护模式下时，由于段基址已经存入了段描述符中，所有段寄存器存入的是一个叫做选择子的东西-sector。其相当于一个索引值。

由于段寄存器是16位，所以选择子也是16位，在其低2位即0~1位存储**RPL**即请求特权级，可以表示0，1，2，3四种特权级。在选择子第2位是TI位即**Table Indicator**，用来指示选择子是在GDT中，还是LDT中索引描述符。TI为0表示在GDT中索引描述符。

**选择子的作用主要是确定段描述符。确定描述符的目的，一是为了特权级，界限等安全考虑，最主要还是要确定段的基地址**。

![image-20220705144537597](D:/TYPIC/image-20220705144537597.png)

给出选择子索引到描述符后，CPU自动从段描述符中取出基地址，这样再加上段内偏移地址，凑成地址的形式。

![image-20220705145430112](D:/TYPIC/image-20220705145430112.png)

值得注意的是上面括号中提到了GDT中的第0个段描述符是不可用的，原因是定义在GDT中的段描述符是要用选择子来访问的。如果使用的选择子忘记初始化，选择子的值便会是0，这便会访问到第0个段描述符，GDT的第0个段描述符是不可用的，这样CPU会出现报错处理。



`按理说有全局就要有局部，还真有，这就是局部描述符表LDT ，Local Descriptor Table。它是CPU厂商为在硬件一级原生支持多任务而创造的表，按其设想，一个任务对应一个LDT，其实在现代OS中很少用LDT的。CPU厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，注意是其自己的段描述符表即LDT，每个任务都有自己的LDT，随着任务切换，也要切换相应任务的LDT。LDT也位于内存中，其地址需要被加载到某个寄存器后，CPU才能使用LDT，该寄存器即为LDT Register。同样也有专门的指令用于加载LDT，即lldt，以后每切换任务时，都要用lldt指令重新加载任务的私有内存段。     `





## 实模式和保护模式的地址回绕

解决方案：打开A20或关闭A20来决定在保护模式下是否地址回绕

打开A20Gate的方式极其简单，将端口0x92的第1位置1就可以了，以下三个步骤即可实现。

```asm
in al,0x92
or al,0000_0010B
out 0x92,al
```

## 保护模式的开关,CR0寄存器的PE位

控制寄存器系列CRx是CPU的窗口，既可以用来展示CPU的内部状态，也可以用于控制CPU的运行机制。这次用到的是CR0寄存器。更准确地说，要用到CR0的第0位，即PE位，Protection Enable，此位用于启动保护模式。是保护模式的开关。

PE为0表示在实模式下运行，PE为1表示在保护模式下运行。

![image-20220705161925670](D:/TYPIC/image-20220705161925670.png)

开启示例代码如下

```asm
mov eax,cr0
or eax,0x00000001
mov cr0,eax
```





构建源码

```asm
%include "boot.inc"

;设置加载器加载的虚拟地址boot.inc中定义为0x900
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR


jmp loader_start 

;第一个段描述符不可用设置为0
GDT_BASE:
	dd 0x00000000
	dd 0x00000000

;代码段描述符，代码由低地址向高地址扩展故前面的为低4B内存,平坦模式下，段的基址都是0
CODE_DESC:
	dd 0X0000ffff
	dd DESC_CODE_HIGH4

;栈段描述符，与数据段共享
DATA_STACK_DESC:
	dd 0x0000ffff
	dd DESC_DATA_HIGH4

;显卡段描述符，采用非平坦模式
VIDEO_DESC:
	dd 0x80000007     ;界限=(0xbfff-0xb8000)/4k=0x7,段基址设置为文本起始地址0xb8000
	dd DESC_VIDEO_HIGH4

GDT_SIZE equ $ - GDT_BASE    ;获取GDT表大小
GDT_LIMIT equ GDT_SIZE - 1    ;获取GDT表段界限,为后来的GDTR初始化有用
times 60 dq 0   ;预留60个段描述符

;段描述符构造完,定义选择子
SELECTOR_CODE equ (0x0001<<3) + TI_GDT + RPL0
SELECTOR_DATA equ (0x0002<<3) + TI_GDT + RPL0
SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0


;准备工作完毕,构造一个48位数据给GDTR以维护
gdt_ptr dw GDT_LIMIT
	dd GDT_BASE


loadermsg db '2 loader in real.'


;;;;;;;;;;;	CPU执行代码段	;;;;;;;;;

loader_start:
	;调用BIOS 10h号中断显示字符串
mov byte [gs:0x00],'H'
mov byte [gs:0x01],0xA4

	
	mov sp,LOADER_BASE_ADDR
	mov bp,loadermsg	  
	mov cx,17                 ;字符串长度为17
	mov ax,0x1301
	mov bx,0x001f
	mov dx,0x1800
	int 0x10

	;开始进入保护模式
	;打开A20地址线
	in al,0x92;
	or al,00000010b
	out 0x92,al




	;加载gdt
	lgdt [gdt_ptr]


	;打开CR0的PE位
	mov eax,cr0
	or eax,0x00000001
	mov cr0,eax


	;刷新流水线
	jmp dword SELECTOR_CODE:p_mode_start

    ;CPU虽然进入保护模式，但默认是16位编译，CPU有流水线，将本来该编译成32位的指令译码并放到流水线上，如果不清空流水线，将会产生16位的指令，导致出现错误。伪指令dword会将机器码反转，代码段寄存器cs，只有用远过程调用指令call,远转移指令jmp,远返回指令retf等指令间接改变，没有直接改变cs的方法。CPU遇上jmp指令时，之前的流水线上的指令只有清空，所以jmp指令有清空流水线的神奇功效。

;开始利用保护模式寻址写命令
[bits 32]
p_mode_start:
	mov ax,SELECTOR_DATA
	mov ds,ax
	mov es,ax
	mov ss,ax
	mov esp,LOADER_STACK_TOP
	mov ax,SELECTOR_VIDEO
	mov gs,ax
	;将各个寄存器指向所需选择子，初始化完毕;


	mov byte [gs:160],'L'
	mov byte [gs:161],0x1f
	mov byte [gs:162],'B'
	mov byte [gs:163],0x1f
	mov byte [gs:164],'Q'
	mov byte [gs:165],0x1f

	jmp $

```



MBR和LOADER配合

MBR使用硬盘，用硬盘控制器IO接口使硬盘读取其里面的loader文件，使其加载到到0x900，然后执行loader里面的指令（汇编后是：jmp loader_start 跳过数据段）来到0x900+0x21a=0xbla







